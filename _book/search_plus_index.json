{"./":{"url":"./","title":"Introduction","keywords":"","body":"纽扣夹子的笔记 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:42:35 "},"book/linux/readme.html":{"url":"book/linux/readme.html","title":"Linux","keywords":"","body":"Linux使用笔记 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/linux/contos-config.html":{"url":"book/linux/contos-config.html","title":"Centos配置","keywords":"","body":"centos 配置 ssh连接时间 因为ssh一般会默认几分钟内五操作就自动断开连接，而我 平时切出去查点资料就自己断开了，挺难受的，就改了配置文件 修改配置文件/etc/ssh/ssh_config(服务器和本地的位置一样) sudo vim /etc/ssh/ssh_config 本地linux配置 ServerAliveInterval 50 ServerAliveCountMax 3 远程服务器上配置 ClientAliveInterval 50 ClientAliveCountMax 3 在linux上添加新用户 useradd username 使用useradd添加用户，username是要建立用户的名字 passwd username 使用passwd来修改用户的密码 su username 切换到指定用户 设置允许普用用户使用sudo命令，必须使用root权限的帐号执行visudo,直接修改/etc/sudoers文件也可做到，但visudo可以对输入进行语法检查，因为sudoers文件语法错误回导致所有sudo命令都无法使用 具体设置： visudo 执行这个命令后会打开文件 找到 root ALL=(ALL) ALL这行，在其下新增一行 username ALL=(ALL) ALL注意这里的空格是tab，为防止出错建议直接复制root那行下来再做修改 保存并退出就可 linux下添加用户并赋予root权限 修改 /etc/passwd 文件，找到如下行，把用户ID修改为 0 ，如下所示： tommy:x:0:33:tommy:/data/webroot:/bin/bash Ubuntu安装WPS Ubuntu 18.04 LTS 安装WPS linux版WPS地址 先到官网下载最新版，运行命令安装 运行安装包 sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb 运行命令，修复依赖 sudo apt install -f 安装需要的软件包并重新安装wps wget http://kr.archive.ubuntu.com/ubuntu/pool/main/libp/libpng/libpng12-0_1.2.54-1ubuntu1_amd64.deb sudo dpkg -i libpng12-0_1.2.54-1ubuntu1_amd64.deb sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb 字体缺失问题： 国内下载地址（百度云） # a. 将得到文件复制到/usr/share/fonts sudo cp * /usr/share/fonts # b. 执行以下命令,生成字体的索引信息 sudo mkfontscale sudo mkfontdir # c. 更新字体缓存 sudo fc-cache MySQL安装 先下载源 wget 'https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm 再使用yum localinstall命令将mysql源添加进/etc/yum.repos.d sudo yum localinstall mysql80-community-release-el7-1.noarch.rpm 之后就是安装 sudo yum install mysql-community-sever 如果启动mysql时报错 Job for mysqld.service failed because the control process exited with error code. See \"systemctl status mysqld.service\" and \"journalctl -xe\" for details. 有可能是/var/lib/mysql的目录不是空的，将这个目录删除在重新建一个空目录来启动mysql 由于新版本的Mysql没有默认密码，而是在一开始安装完成后产生一个随机密码， 需要在启动日志中找到这个密码才能登录MySQL 首先，先运行MySQL来时日志产生 centos下启动命令是 systemctl start mysqld.service 而ubuntu下则是 service mysqld start 运行一次之后就可以在日志文件/var/log/mysql.log中找到日志文件， 但因为日志就算只是启动一次依旧产生了很多，要找到一串随机密码还是很累的 可以使用 grep \"temporary password\" /var/log/mysqld.log 直接定位到那段密码 之后就需要使用获得的随机密码登录后并修改Mysql的密码 GRANT ALL PRIVILEGES ON *.* TO 'root'@localhost IDENTIFIED BY 'PASSWORD'; 或则 alter user 'root'@'localhost' identified by '123'; 安装Python3 因为现在趋势就是新的python3，而python2正在逐渐被替换，所以还是升级以下服务器上 python的版本 首先，安装以下依赖 yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 添加epel扩展 yum -y install epel-release 使用wget下载python3.7 wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz 解压缩包 xz -d Python-3.7.0.tar.xz tar -xf Python-3.7.0.tar 进入解压缩后的目录 cd python-3.7.0 现在就可以准备配置文件，但在这之间可以先安装gcc编译环境 sudo yum install -y gcc 执行手动编译将python3.7安装到/usr/local ./configure prefix=/usr/local/python3 之后需要标记，标记需要使用root帐号 sudo su 切换到root帐号后 make && make install 如果没有报错就说明正确安装了，可以在/usr/local下看到python目录 如果出现错误 ModuleNotFoundError: No module named '_ctypes' 可能是由于python3.7需要一个新的依赖包，安装一下 yum install libffi-devel -y 在重新mark之后就行了 之后就可以使用python3来使用python3.7，而python2直接python就额可以 但我们现在主要用的是python3，所以可以添加软链接 先将原来的python备份 mv /usr/bin/python /usr/bin/python.bak 添加python3的软连接 sudo ln -s /usr/local/python3/bin/python3.7 /usr/bin/python 完成后测试一下 python -V 输入python3.7就说明成功了 最后修改yum的软连接，让其指向python3 sudo vi /usr/bin/yum 将开头的# ! /usr/bin/python 改为 # ! /usr/bin/python2 sudo vi /usr/libexec/urlgrabber-ext-down 同样将开头的改为 # ! /usr/bin/python2 由于防火墙也是使用python2,所以防火墙的配置也要修改 sudo vim /usr/bin/firewall-cmd 将# !/usr/bin/python -Es 改为 # !/usr/bin/python2 sudo vim /usr/bin/firewall-offline-cmd 将# !/usr/bin/python -Es 改为 # !/usr/bin/python2 /usr/sbin/firewalld通用做修改 以免防火墙报错，找不到gi模块 vim /usr/sbin/firewalld 安装pip yum -y install epel-release yum install python-pip pip install --upgrade pip 安装vim 先检查一些vim是否安装，缺了哪些 rpm -qa|grep vim 如果输出的内容中 vim-common,vim-enhanced,vim-minimal，vimfilesystem 四个包都有表示安装成功，缺哪个就安装哪个，比如缺少vim-enhaced yum -y install vim-enhanced 之后可以对vim做一些配置，以便其使用，vim很强，我就用一点的就够用了 在用户目录下新建文件.vimrc touch .vimrc 进入配置 vim .vimrc 输入配置内容 set nu // 这是设置显示行号 set showmode //设置在命令行界面最下面显示当前模式等。 set ruler // 在右下角显示光标所在的行数等信息 set autoindent // 设置每次单击Enter键后，光标移动到下一行时与上一行的起始字符对齐 syntax on // 即设置语法检测，当编辑C或者Shell脚本时，关键字会用特殊颜色显示 set tabstop=4 //设置tab键缩进为4 set shiftwidth=4 //设置每一级的缩进长度 //解决中文乱码 set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 set enc=utf8 set fencs=utf8,gbk,gb2312,gb18030 方向键乱码问题（^[[A^[[B^[[C^[[D） 参考： ssh 连上服务器之后，终端的上下左右键变成乱码，着急哦～～～！！ [在Linux中，按上下左右键为什么变成^[[A^[[B^[[C^[[D？](https://www.zhihu.com/question/31429658) 造成这种情况可能是创建用户是没有指定环境 需要将用户环境改为 /bin/bash sudo vim /etc/passwd 找到需要修改的用户在后面加上/bin/bash 或者，在终端中输入 >> bash >> chsh 在Login Shell [*]后输入： /bin/bash By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/linux/ubuntu-install.html":{"url":"book/linux/ubuntu-install.html","title":"Ubuntu安装","keywords":"","body":"Ubuntu安装 由于安装ubuntu16.04时只分配了25G的空间，想要升级到18.04时存储下载软件的 挂载/usr内存不够，无法下载系统更新上去，于是打算再将windows空间切一些 下来，压缩windows下分卷之后，问题出现了 由于压缩分卷之后硬盘分区改变，导致windows和ubuntu的启动引导全部丢失，完 全无法进入系统，开机直接进入grub的界面，似乎可以用来修复启动引导。 但是这个东西，建议像我这种萌新就别碰了，太菜，搞不来，头大。 浪费了一天时间后还是决定直接重装系统，所有的一起，再次回到起点 windows10还是没什么差别，刻录系统盘之后就开始安装，这里碰到了安装系统 的第一个问题，windows使用UEFI引导安装时检测硬盘分区不对，似乎是文件系统里有其他的 文件系统导致，具体提示因为没有及时记录已经忘了。 解决方案是： 将系统盘拔出来，将其中的efi目录和另一个带有efi后缀的文件移除，并在安装 时使用BIOS安装（UEFI上面那个没带U盘名字的启动项）安装就行了 之后是ubuntu18.04的安装 关于ubuntu的安装之前一直没搞懂，经过这次才有点明白了 参考： Windows10+Ubuntu18.04双系统安装成功心得（理清网上杂乱无章的教程） 其中几个我觉得需要注意的地方 使用 Rufus 刻录系统盘 使用BIOS进入启动盘，千万不要用UEFI启动，否则ubuntu会识别不到系统中已安装的windwos 如果安装时没有看到“安装ubuntu与windows10系统共存”的选项，请退出去重新检查系统盘刻录 最主要的是，只要在安装时有提示共存的选项就可以在安装好双系统时默认使用 ubuntu引导启动系统 关于ubuntu的系统分区/挂载点 创建主分区： 150G 主分区 空间起始位置 分区格式为ext4 / 建议：安装系统和软件，分区尽量大设置大点 创建swap分区：2048MB 逻辑分区 空间起始位置 分区格式为swap 交换分区相当于Windows中的“虚拟内存”，如果物理内存小于或等于512MB，建议分配交换分区的大小为物理内存容量的2倍；如果物理内存大于512MB，建议分配交换分区的大小等于物理内存容量；如果您的内存够大也可以不建立交换分区。 创建boot分区：1GB 逻辑分区 空间起始位置 分区格式为ext4 /boot 建议：400MB或1GB 启动分区，包含操作系统内核和启动的程序 创建home分区: 剩余的空间 逻辑分区 空间起始位置 分区格式为ext4 /home 建议： 相当于“我的文档”，分区尽量大设置大点 Ubuntu分区方案 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/linux/ubuntu-wine.html":{"url":"book/linux/ubuntu-wine.html","title":"Ubuntu安装wine","keywords":"","body":"Ubuntu环境安装wine 在ubuntu环境下安装wine QQ轻聊版 参考 最新wineQQ 完美解决方案 需要先安装deepin-wine环境 安装git来克隆github项目 sudo apt-get install git 安转号git后使用其克隆项目 git clone \"https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git\" 下载好之后进入下载好的文件夹并将其一键安装 cd deepin-wine-for-ubuntu sudo sh ./install.sh 安装好环境之后就需要安转应用容器,到这个网址下载 http://mirrors.aliyun.com/deepin/pool/non-free/d/ 推荐： QQ：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/ TIM：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/ QQ轻聊版：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/ 微信：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/ Foxmail：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.foxmail/ 百度网盘：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.baidu.pan/ 360压缩：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.cn.360.yasuo/ 中文乱码（宋体） 参考 彻底消除wine中文乱码 如何解决wine中文乱码问题 第一杯红酒：Wine让Windows程序运行在Linux上 simsun.ttc 下载字体 $ wget https://github.com/sonatype/maven-guide-zh/raw/master/content-zh/src/main/resources/fonts/simsun.ttc 将字体复制到指定文件夹 $ cp simsun.ttc /home/username/.wine/drive_c/windows/Fonts/ Font文件夹下，该文件夹由wine生成类似windows的目录，如果找不到可以 $ find /|grep 'windows/Fonts' 之后创建一个文件zh.reg，这是windows的注册表脚本，因为需要在windows 环境下执行，所以也必须使用wine zh.reg REGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes] “Arial”=”simsun” “Arial CE,238”=”simsun” “Arial CYR,204”=”simsun” “Arial Greek,161”=”simsun” “Arial TUR,162”=”simsun” “Courier New”=”simsun” “Courier New CE,238”=”simsun” “Courier New CYR,204”=”simsun” “Courier New Greek,161”=”simsun” “Courier New TUR,162”=”simsun” “FixedSys”=”simsun” “Helv”=”simsun” “Helvetica”=”simsun” “MS Sans Serif”=”simsun” “MS Shell Dlg”=”simsun” “MS Shell Dlg 2”=”simsun” “System”=”simsun” “Tahoma”=”simsun” “Times”=”simsun” “Times New Roman CE,238”=”simsun” “Times New Roman CYR,204”=”simsun” “Times New Roman Greek,161”=”simsun” “Times New Roman TUR,162”=”simsun” “Tms Rmn”=”simsun” 执行文件 $ wine regedit zh.reg # 由于我是使用deepin-wine,所以我是这么做 $ /usr/bin/deepin-wine regedit zh.reg winetricks Winetricks winetricks wineserver non trovato! 安装 $ wget https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks $ chmod +x winetricks 启动 $ sh winetricks 如果在没有参数的情况下运行，winetricks将显示一个包含可用包列表的GUI。 错误 ------------------------------------------------------ wineserver not found! ------------------------------------------------------ 解决方法：找到winserver制作软链接 $ locate wineserver /usr/lib/i386-linux-gnu/deepin-wine/wineserver /usr/lib/i386-linux-gnu/deepin-wine/wineserver.real $ sudo ln -s /usr/lib/i386-linux-gnu/deepin-wine/wineserver /usr/local/bin/wineserver 其他 文章里还介绍了一个桌面图标样式的东西 sudo apt-get install gnome-shell-extension-top-icons-plus gnome-tweaks 安装好使用命令gnome-tweaks开启这个扩展 gnome可以对直接ubuntu的皮肤进行修改，其中可以自己安装一些皮肤 How To Install the Adapta GTK Theme on Ubuntu ubuntu18.04 初体验 -- 自定义主题和配置 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/linux/linux-operation.html":{"url":"book/linux/linux-operation.html","title":"Linux配置","keywords":"","body":"Linux操作 zip 使用zip命令解压文件到制定目录 unzip filename.zip -d indexname 其中unzip时zip解包命令，-d用于指定要解压到的目录 unar 解压windows系统下压缩的zip文件时，会产生中文乱码现象 $ sudo apt-get install unar $ unar your.zip centos 端口 centos7 firewalld(防火墙)和systemctl(开机启动服务)相关%E5%92%8Csystemctl(%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1)%E7%9B%B8%E5%85%B3) centos上防火墙的端口设置 centos7默认是没有iptables，所以通过iptables命令来配置是不可以的 centos采用了firewalld防火墙 查看80端口是否开启 firewall-cmd --query-port=80/tcp 开启80端口 firewall-cmd --zone=public --add-port=80/tcp --permanent 命令含义： --zone 作用域 --add-port=80/tcp 添加端口，格式为：端口号/通讯协议 --permanent 永久生效 添加后要重启才能生效 firewall-cmd --reload 查看已开启的端口 firewall-cmd --list-ports 关闭80端口 firewall-cmd --remove-port=80/tcp --permanent unix环境下小于1024的端口不能被用户直接使用(可以试一下sudo) 文件传输 从服务器上下载文件目录 需要先在服务器上安装vsftpd 检查是否安装过 rmp -q vsftpd 如果没有安装的话，使用 yum -y install vsftpd 启动vsftpd server vsftpd start 检查vsftpd是否开启 ps -e | grep vsftpd 检查21端口是否被监听 netstat -an | grep 21 注意：ftp协议是使用21号端口，所以21号端口必须开启 其实也可以不用那么麻烦 要下载目录直接在本地使用wget命令就行 wget ftp://45.77.95.163:21/ --ftp-user=junhan --ftp-password=@Jun8196285 -r ftp跟上要连接的服务器ip:端口号，之后跟上登录ftp的用户名和密码 这个用户名和密码直接可以使用登录服务器的用户名和密码，或则可以创建单独作为ftp使用的用户名和密码，这个暂时没有去研究怎么创建 可以使用scp命令上传和下载 上传单个文件 scp -p port source_dictionary_file user@serverip:target_dictionary_file port位置输入端口 source_dictionary_file 源文件的名字/位置 target_dictionary_file 目标地点的地址，必须是在服务器上存在的目录 或则使用另一个 scp /user/hellowood/wechar.jpg root@ip:/home/hellword/wechat.jpg 和上面一样，源文件地址和目标地址一定要正确 上传整个文件夹 scp -p port -r source_dictionary user@serverip:target_dictionary 或则 scp -r /userfile/file root@serverip:/home/file 对来，只要上面的用户名和密码正确，就会要求输入密码 下载 scp -p user@serverip:source_dictionary_file target_dictionary 或则 scp root@serverip:/home/file.jpg /home/wechat.jpg 下载整个文件夹 scp -p port -r user@serverip:/home/file /home/fiele2 Linux系统错误 /etc/porfileh这个文件不能乱改一旦出错都将导致整个命令行的命令都无法使用 如果发生这种情况可以使用 export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 这句来修改系统配置，就可重新使用，之后就将porfile文件改正确 定义别名 # 示例：查看80端口 $ alias ps8='ps -aux | grep 80' # 之后只需要执行ps8便可 批量删除有相同字符的文件 参考：linux 删除所有后缀名相同的文件 $ find . -name '*.log' -exec rm -rf {} \\; find查找文件 -name根据某个字符查找，支持正则匹配 -exec后面跟一个指令，表示将前面得到的所有结果都一一执行该指令 {}占位符，会将前面匹配到的内容替换过来 \\;不知道啥东西，可能是格式吧 netstat 　-t : 指明显示TCP端口 　-u : 指明显示UDP端口 　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序) 　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。 　-n : 不进行DNS轮询，显示IP(可以加速操作) 使用 $ netstat -tulpn |grep 10000 查询10000端口的使用情况 批量替换 sed -i \"s/查找字段/替换字段/g\" grep 查找字段 -rl 路径 或者 grep -rl 查找字段 路径|xargs sed -i \"s/查找字段/替换字段/g\" grep print.* -rl ./ | xargs sed -i \"s/print\\(.*\\)/print(\\1)/g\" By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/linux/env-coding-error.html":{"url":"book/linux/env-coding-error.html","title":"Linux环境编码错误","keywords":"","body":"环境编码错误 使用django时出现错误 Traceback (most recent call last): File \"/usr/local/lib/python3.6/dist-packages/django/core/handlers/exception.py\", line 34, in inner response = get_response(request) File \"/usr/local/lib/python3.6/dist-packages/django/utils/deprecation.py\", line 94, in __call__ response = response or self.get_response(request) File \"/usr/local/lib/python3.6/dist-packages/django/core/handlers/exception.py\", line 36, in inner response = response_for_exception(request, exc) File \"/usr/local/lib/python3.6/dist-packages/django/core/handlers/exception.py\", line 80, in response_for_exception response = debug.technical_500_response(request, *sys.exc_info(), status_code=400) File \"/usr/local/lib/python3.6/dist-packages/django/views/debug.py\", line 94, in technical_500_response html = reporter.get_traceback_html() File \"/usr/local/lib/python3.6/dist-packages/django/views/debug.py\", line 332, in get_traceback_html t = DEBUG_ENGINE.from_string(fh.read()) File \"/usr/lib/python3.6/encodings/ascii.py\", line 26, in decode return codecs.ascii_decode(input, self.errors)[0] UnicodeDecodeError: 'ascii' codec can't decode byte 0xe2 in position 9735: ordinal not in range(128) 环境编码问题，解决方法就是修改环境变量，将编码改为utf-8 $ export LC_ALL=en_US.UTF-8 $ export LANG=en_US.UTF-8 $ export LANGUAGE=en_US.UTF-8 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:26:50 "},"book/linux/ssh.html":{"url":"book/linux/ssh.html","title":"ssh密钥","keywords":"","body":"SSH秘钥(免密登录) 配置SSH秘钥，以达成免密登录服务器的效果 秘钥 SSH密钥提供一种更为安全的虚拟专有服务器登录机制。 不通过密码登录，而是通过ssh完成登录。使用ssh登录时，实际上客户端会优先使用秘钥 来与服务器进行配对(可以通过在命令中加入-v来查看，即ssh -v name@server) ，配对成功则直接登录（免密登录），配对失败将会尝试使用密码登录远程服务器。 ssh秘钥几乎无法以暴力方式破解。配置好服务器（公钥）和客户端（秘钥）之后便可。 生成秘钥对 在linux下使用命令 # 1、开始生成秘钥对 $ ssh-keygen # 提示秘钥需要保存的位置以及秘钥的名称，默认回车便可 Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. # 这里提示的密码是在使用秘钥时是否需要输入秘密，又不是什么军方需要特别秘密的东西，直接回车跳过 Enter passphrase (empty for no passphrase): Enter same passphrase again: # 完成后会提示类似的内容 Your identification has been saved in /home/demo/.ssh/id_rsa. Your public key has been saved in /home/demo/.ssh/id_rsa.pub. The key fingerprint is: 4a:dd:0a:c6:35:4e:3f:ed:27:38:8c:74:44:4d:93:67 demo@a The key's randomart image is: +--[ RSA 2048]----+ | .oo. | | . o.E | | + . o | | . = = . | | = S = . | | o + = + | | . o + o . | | . o | | | +-----------------+ 见到类似上面的输出，说明秘钥已经创建好了，可以在用户目录下找到，移动到用户目录下 # 移动到用户目录下 $ cd /home/user/.ssh # 查看目录下文件 $ ls -al id_rsa id_rsa.pub 其中id_rsa是私钥，绝对不能给任何人，id_rsa.pub这个以.pub后缀的是 公钥，可以随意告别人。 要使用免密登录需要将公钥交给服务器来保管，以便服务器根据公钥来与客户端 的私钥配对 在远程服务器上保存公钥 要将公钥提交到服务器上，一般有两种方法 一、ssh-copy-id ssh-copy-id name@server 二、直接登录服务器完成复制 这里使用scp命令将文件复制到服务器上 # 先将文件复制到服务器上 $ scp /home/user/.ssh/id_rsa.pub user@server:./.ssh # 再将文件追加到`authorized_keys`内 $ cat /home/user/.ssh/idrsa.pub >> authorized_keys 其实直接查看id_rsa.pub文件，复制其内容，再直接粘贴到authorized_keys 文件末尾也是可以的 配置ssh 远程服务器上打开秘钥登录功能 编辑/etc/ssh/sshd_config文件，找到以下几项并修改如下 RSAAuthentication yes PubkeyAuthentication yes 允许root用户使用密码登录 PermitRootLogin yes 如果需要禁用其他用户登录 PasswordAuthentication no 最后重启ssh服务 service sshd restart 出现的问题 如果按上文配置好后还是需要密码登录，可以进行以下检查 检查客户端ssh配置文件 找到ssh_config进行编辑，这个文件位置一般在/etc/ssh/ssh_config $ vim /etc/ssh/ssh_conig 找到 IdentityFile ~/.ssh/id_rsa 这行，这行的意思是告诉客户端，使用秘钥登录时的客户端私钥可以在哪里找到。 一般默认是在~/.ssh/id_rsa，如果私钥位置有更改，可以根据实际情况增加一行， 比如： IdentityFile ~/.ssh/id_git 检查远程服务器上的文件使用权限 这里的文件指的是.ssh文件夹权限和authorized_keys文件。 必须保证这两个文件只有该账户的用户能修改，以免被其他人修改。 所以，这里有两个注意点，一个是文件夹权限，一个是文件的所有者 可以通过命令ls -al来查看 $ ls -al drwx------ 2 root www-data 4096 Jan 29 15:39 .ssh $ ls -al .ssh drwx------ 2 root www-data 4096 Jan 29 15:39 . drwxrwxrwx 10 root root 4096 Feb 3 19:54 .. -rw------- 1 root www-data 1194 Jan 29 15:39 authorized_keys 权限修改为 $ chmod 600 authorized_keys $ chmod 700 .ssh 使用ls -al可以看到，当前文件的所有者是root用户，需要修改给指定的普通用户。 但是普通用户并没有权限可以创建文件夹（没有'写'权限）。 可以通过两个方法，给普通用户修改权限，或则由有权限的用户创建后再转给普通用户。 这里就只讲将文件所有权改给普通用户 $ chown git authorized_keys $ chown git .ssh 参考 Ssh 信任关系建立后仍需要输入密码 配置ssh公钥登录提示还是输入密码 设置 SSH 通过密钥登录 如何设置SSH密钥 如何更改linux文件的拥有者及用户组(chown和chgrp) By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/linux/Tcpdump.html":{"url":"book/linux/Tcpdump.html","title":"Tcpdump抓包工具","keywords":"","body":" Tcpdump 抓包工具 抓包工具 tcpdump 抓包神器 tcpdump 使用介绍 CentOS下使用tcpdump网络抓包 tcpdump常用参数说明 监听指定端口 $ tcpdump -i eth0 -nnA ‘port 80’ By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:21:24 "},"book/linux/VIM.html":{"url":"book/linux/VIM.html","title":"VIM","keywords":"","body":"VIM 参考： Vim删除并进入插入模式命令c(change)-Vim入门教程(21) vim内想要搜索某个字符可以在命令行模式下使用/开始，之后输入要查找的字符 例如，需要在vim内查找字符窗self可以 /self 然后回车 其中，特殊字符需要使用\\反斜杠来转义字符 查找字符后可以在命令模式下使用，n上一个|N下一个来切换 G(shift + n)来跳转到末行 gg跳转到开头 ctrl + F向下翻页 ctrl + B向上翻页 ctrl + E向下滚屏 ctrl + Y向上滚屏 cc删除当前行并开始编辑 C删除当前行光标位置后面的内容，包括光标位置的字符 dd剪切光标所在行 yy复制光标所在行，包括行号 a在当前光标位置后开始编辑 A在当前光标所在行末尾开始编辑 i在当前光标所在位置开始编辑 I在当前光标所在行开头开始编辑 dG删除光标所在位置后面所有内容 o在当前光标下一行开始编辑（新的一行） O在当前光标上一行开始编辑（新的一行） ciw删除光标所处位置单词并进入插入模式 dw删除光标所处位置单词 指令模式下 set autoindent设置自动缩排 set nu设置行号显示 set highlight高亮设置查看 set hlsearch查找代码高亮显示 set nohlsearch关闭高亮显示（本次编辑永久关闭） nohlsearch暂时关闭高亮显示 操作中文 VIM中使用正则匹配中文 命令模式下操作 g/print/d 删除包含指定字符的行 g!/print/d 删除不包含指定字符的行 本次编辑取消自动缩进 取消了自动缩进和智能缩进vim :set paste 选择粘贴 yiw 选择需要复制的单词 viwp 使用寄存器中的文本替换选中的文本 vi 移动光标选中一定长度文本再按 p 也可实现 参考：Vim:快速复制和替换 寄存器 \"是默认寄存器，简单操作寄存器： \"ayy 将当前行复制到名为a的寄存器中 \"ap将名为a的寄存器中的内容粘贴出来 其他 \\ 匹配单词开头 \\> 匹配单词结尾 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/readme.html":{"url":"book/python/readme.html","title":"Python","keywords":"","body":"By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:58:12 "},"book/python/crc.html":{"url":"book/python/crc.html","title":"CRC循環冗餘校驗","keywords":"","body":"循環冗餘校驗(CRC) 关于CRC校验 参考： 循環冗餘校驗 二进制数的运算方法 模除 循环冗余校验（CRC）算法入门引导 python CRC16检验 官方模块 crccheck 0.6 在线CRC工具 CRC（循环冗余校验）在线计算 实际使用 按照官方文档上，只需要按照类名引入模块就可使用 在在线CRC校验工具上检测，确认了项目需要的是 CRC-16/25 x16+x12+x5+1 from crccheck.crc import CrcX25 crcx = CrcX25() data1= bytes.fromhex('11010752533678900242700032010005') crcx.process(data1) s = crcx.finalhex() 最终得到结果 >> '1279' 这个结果和在线工具上测试的相同，暂且能用，达到了目的，所以暂告一段落 顺便贴上官方CRC类的类名和使用说明 Project description The crccheck.crc module implements all CRCs listed in the Catalogue of parametrised CRC algorithms: CRC-3/ROHC, CRC-4/ITU, CRC-5/EPC, CRC-5/ITU, CRC-5/USB, CRC-6/CDMA2000-A, CRC-6/CDMA2000-B, CRC-6/DARC, CRC-6/ITU, CRC-7, CRC-7/ROHC, CRC-8, CRC-8/CDMA2000, CRC-8/DARC, CRC-8/DVB-S2, CRC-8/EBU, CRC-8/I-CODE, CRC-8/ITU, CRC-8/MAXIM, CRC-8/ROHC, CRC-8/WCDMA, CRC-10, CRC-10/CDMA2000, CRC-11, CRC-12/3GPP, CRC-12/CDMA2000, CRC-12/DECT, CRC-13/BBC, CRC-14/DARC, CRC-15, CRC-15/MPT1327, CRC-16, ARC, CRC-16/AUG-CCITT, CRC-16/BUYPASS, CRC-16/CCITT-FALSE, CRC-16/CDMA2000, CRC-16/DDS-110, CRC-16/DECT-R, CRC-16/DECT-X, CRC-16/DNP, CRC-16/EN-13757, CRC-16/GENIBUS, CRC-16/MAXIM, CRC-16/MCRF4XX, CRC-16/RIELLO, CRC-16/T10-DIF, CRC-16/TELEDISK, CRC-16/TMS37157, CRC-16/USB, CRC-A, CRC-16 CCITT, KERMIT, MODBUS, X-25, XMODEM, CRC-24, CRC-24/FLEXRAY-A, CRC-24/FLEXRAY-B, CRC-31/PHILIPS, CRC-32, CRC-32/BZIP2, CRC-32C, CRC-32D, CRC-32/MPEG-2, CRC-32/POSIX, CRC-32Q, JAMCRC, XFER, CRC-40/GSM, CRC-64, CRC-64/WE, CRC-64/XZ, CRC-82/DARC. For the class names simply remove all dashes and slashes from the above names and apply CamelCase, e.g. “CRC-32/MPEG-2” is implemented by Crc32Mpeg2. Other CRC can be calculated by using the general classcrccheck.crc.Crc by providing all required CRC parameters. The crccheck.checksum module implements additive and XOR checksums with 8, 16 and 32 bit: Checksum8, Checksum16, Checksum32 and ChecksumXor8, ChecksumXor16, ChecksumXor32 Usage example: from crccheck.crc import Crc32, CrcXmodem from crccheck.checksum import Checksum32 Quick calculation data = bytearray.fromhex(\"DEADBEEF\") crc = Crc32.calc(data) checksum = Checksum32.calc(data) Procsss multiple data buffers data1 = b\"Binary string\" # or use .encode(..) on normal sring - Python 3 only data2 = bytes.fromhex(\"1234567890\") # Python 3 only, use bytearray for older versions data3 = (0x0, 255, 12, 99) # Iterable which returns ints in byte range (0..255) crcinst = CrcXmodem() crcinst.process(data1) crcinst.process(data2) crcinst.process(data3[1:-1]) crcbytes = crcinst.finalbytes() crchex = crcinst.finalhex() crcint = crcinst.final() By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/python-xadmin.html":{"url":"book/python/python-xadmin.html","title":"python xadmin模块","keywords":"","body":"Python 模块 xadmin 安装问题 参考 Django2.1集成xadmin管理后台所遇到的错误集锦，解决填坑 cannot import name 'password_reset_confirm' django2.x报错No module named 'django.core.urlresolvers' 前言 将项目的django升级到2.1之后，xadmin爆炸了，网上资料比较齐全，这里多此一举 整合一下 手动安装xadmin模块 下载 从这里下载 手动安装 $ pip install xadmin-master.zip 如果安装出现问题，可以尝试使用一个空文件重命名为README.rst，替换掉 zip包内的README.rst文件 解决兼容问题 ModuleNotFoundError: No module named 'django.core.urlresolvers' 原因为django2.0将包django.core.urlresolvers重命名为django.urls。 因此，只要将所有引用该包的地方全部改成django.urls，比如 from django.core.urlresolvers import reverse # 改为 from django.urls import reverse ForeignKey引发的错误 将所有使用models.ForeignKey的地方，在后面补上引用外键on_delete=models.CASCADE user = models.ForeignKey(AUTH_USER_MODEL) # 改为 user = models.ForeignKey(AUTH_USER_MODEL,on_delete=models.CASCADE) dashboard.py文件出现参数数量问题 File \"...\\xadmin\\views\\dashboard.py\",line 285 ,in __init__ .... TypeError: __init__() takes 1 positional argument but 6 were given 解决方法： forms.Field.__init__(self, required, widget, label, initial, help_text, *args, **kwargs) # 改为 forms.Field.__init__(self) ImportError: cannot import name 'login' from 'django.contrib.auth.views' # 将 from django.contrib.auth.views import login from django.contrib.auth.views import logout # 改为 from django.contrib.auth import authenticate, login, logout cannot import name 'password_reset_confirm' # 将 from django.contrib.auth.views import password_reset_confirm # 改为 from django.contrib.auth.views import PasswordResetForm ImportError: cannot import name 'QUERY_TERMS' from 'django.db.models.sql.query' # django2.1.1版本将xadmin\\plugins\\filters.py文件中的 from django.db.models.sql.query import LOOKUP_SEP, QUERY_TERMS # 修改为 from django.db.models.sql.query import LOOKUP_SEP, Query # 在Django2.0版本中把 from django.db.models.sql.query import LOOKUP_SEP, QUERY_TERMS # 修改为： from django.db.models.sql.query import LOOKUP_SEP from django.db.models.sql.constants import QUERY_TERMS ModuleNotFoundError: No module named 'django.contrib.formtools' # 卸载旧版本 pip uninstall django-formtools # 安装新版本 pip install django-formtools By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/python-sockt.html":{"url":"book/python/python-sockt.html","title":"python sockt网络编程","keywords":"","body":"python sockt 网络编程 参考 Python中的socket网络编程(TCP/IP，UDP)讲解 Python socket编程 TCP编程 解决socket.error: [Errno 98] Address already in use问题 实例 # /usr/bin/env python # coding=utf-8 import socket import threading def tcplink(sock,addr): print('Accept new connectin from %s:%s...' % addr) sock.send('welcome'.encode()) # send()发送TCP数据，将string中的数据发送到连接的套接字 while True: data = sock.recv(1024) # recv()接受TCP数据，数据以字符串形式返回，可以指定要接受的最大数据量 if data == 'exit' or not data: break; send_data = ('hello %s' % data).encode() sock.send(send_data) sock.close() print('connetction from %s:%s closed' % addr) s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # AF_INET指定IPv4，SOCK_STREAM指定TCP连接 s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) # 设置给定套接字的选项，（）内容让套接字允许地质重用 s.bind(('127.0.0.1',10001)) # 绑定定制和端口到套接字 s.listen(5) # 开始监听，设置操作系统可以挂起的最大连接数，至少为1，一般为5 print('server is waiting connect...') while True: # 设置一个无限循环来实现监听 sock,addr = s.accept() # accept()被动接受客户端连接，是阻塞式等待连接 # socke,addr = s.recvfrom(1024) print('-'*20,sock,addr) t = threading.Thread(target = tcplink , args = (sock,addr)) # 将套接字内容丢到线程中执行 t.start() # 启动这个线程 客户端 # usr/bin/env python3 # coding=utf-8 import socket import threading s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect(('127.0.0.1',10001)) data = s.recv(1024) print(data) for i in [b'one',b'tow',b'three']: s.send(i) data = s.recv(1024) print(data) s.send(b'exit') s.close() By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/python-unpack.html":{"url":"book/python/python-unpack.html","title":"python打包Django","keywords":"","body":"Pyinstaller 打包 Django 参考 pyinstaller简洁教程 用PyInstaller把Python代码打包成单个独立的exe可执行文件 很重要：pyinstaller 打包总结 Bundling data files with PyInstaller (--onefile) pyinstaller打包django项目 Python3.5 django1.11用pyinstaller打包的一些操作问题 Pyinstaller Using spec File pyinstaller 打包django1.8 快速使用 安装 linux or mac 你可以从PyPi上下载安装，当然也可以使用pip或者easy_install来安装。 1 2 3 pip install pyinstaller or easy_install pyinstaller 版本更新 1 2 3 pip install --upgrade pyinstaller or easy_install --upgrade pyinstaller windows Windows上运行PyInstaller还需要PyWin32或者pypiwin32，其中pypiwin32在你安装PyInstaller的时候会自动安装。 使用PyInstaller PyInstaller分析你的python程序，找到所有的依赖项。然后将依赖文件和python解释器放到一个文件夹下或者一个可执行文件中。 打包成一个文件夹 当使用PyInstaller打包的时候，默认生成一个文件夹，文件夹中包含所有依赖项，以及可执行文件。打包成文件夹的好处就是debug的时候可以清楚的看到依赖项有没有包含。另一个好处是更新的时候，只需要更新可执行文件就可以了。当然缺点也很明显，不方便，不易管理。 1 pyinstaller script.py 那么它是如何工作的呢？PyInstaller的引导程序是一个二进制可执行程序。当用户启动你的程序的时候，PyInstaller的引导程序开始运行，首先创建一个临时的Python环境，然后通过Python解释器导入程序的依赖，当然他们都在同一个文件夹下。 打包成一个文件 我们可以用onefile参数将所有文件打包到一个可执行文件中。 1 pyinstaller --onefile script.py 打包成一个文件相对于文件夹更容易管理。坏处运行相对比较慢。这个文件中包含了压缩的依赖文件拷贝（.so文件）。 当程序运行时，PyInstaller的引导程序会新建一个临时文件夹。然后解压程序的第三方依赖文件到临时文件夹中。这也是为什么一个可执行文件比文件夹中执行的时间要长的原因。剩下的就和上面的一样了。 spec 文件 当你执行下面命令 1 pyinstaller options..script.py PyInstaller首先建一个sepc(specification)文件：script.spec。这个文件的存放地址可以使用参数–specpath= 来定义，默认放在当前文件夹下。 spec文件的作用是什么呢？它会告诉PyInstaller如何处理你的py文件，它会将你的py文件名字和输入的大部分参数进行编码。PyInstaller通过执行spec文件中的内容来生成app，有点像makefile。正常使用中我们是不需要管spec文件的，但是下面几种情况需要修改spec文件： 需要打包资源文件 需要include一些PyInstaller不知道的run-time库 为可执行文件添加run-time 选项 多程序打包 可以通过下面命令生成spec文件 1 pyi-makespec options script.py [other scripts ...] 修改完spec文件，就可以通过下面命令来生成app文件了 1 pyinstaller options script.spec 当通过spec文件来生成app文件的时候只有下面几个参数是有用的： –upx-dir= –distpath= –noconfirm= –ascii spec 文件解析 下面是一个spec文件的例子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 block_cipher = None a = Analysis(['minimal.py'], pathex=['/Developer/PItests/minimal'], binaries=None, datas=None, hiddenimports=[], hookspath=None, runtime_hooks=None, excludes=None, ciper=block_cipher) pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher) exe = EXE(pyz, ...) coll = COLLECT(...) spec文件中主要包含4个class: Analysis, PYZ, EXE和COLLECT. Analysis以py文件为输入，它会分析py文件的依赖模块，并生成相应的信息 PYZ是一个.pyz的压缩包，包含程序运行需要的所有依赖 EXE根据上面两项生成 COLLECT生成其他部分的输出文件夹，COLLECT也可以没有 修改spec文件 我们上面说过有时候PyInstaller自动生成的spec文件并不能满足我们的需求，最常见的情况就是我们的程序依赖我们本地的一些数据文件，这个时候就需要我们自己去编辑spec文件来添加数据文件了。 上面的spec文件解析中Analysis中的datas就是要添加到项目中的数据文件，我们可以编辑datas. 1 2 3 4 5 6 a = Analysis( ... datas = [('you/source/file/path','file_name_in_project'), ('source/file2', 'file_name2')] ... ) 可以认为datas是一个List,每个元素是一个二元组。元组的第一个元素是你本地文件索引，第二个元素是拷贝到项目中之后的文件名字。除了上面那种写法，也可以将其提出来。 1 2 3 4 5 6 7 added_files = [...] a = Analysis( ... datas = added_files, ... ) 其他的二进制文件添加方法类似。 总结 最后简单来说，我们要通过PyInstaller生成可执行的文件主要下面两步。 1 pyinstaller [option] mypython.py option为空生成文件夹，选择onefile，生成一个文件。 如果项目有一些依赖的数据文件，上面生成的二进制文件是无法运行的，这个时候可以通过修改spec文件，让后再用pyinstaller运行spec文件。 1 pyinstaller [option] mypython.spec 当然也按上文那样先生成spec文件。 出现的问题 not module name ... 打包时出线找不到某些模块，使用pyinstaller打包时似乎无法打包进 from module import name 这种格式的模块，所以如果在打包时提示没有找到模块的话，最简单有效的手段 就是将找不到的模块import进文件。 例如我在打包django的主程序manage时出现 not module name 'xadmin.plugins' 最快捷的解决方法是编辑mange.py文件，加上 import xadmin.migrations 就能解决问题。 但是，有些模块，直接import进入主文件可能会导致很多莫名其妙的问题。 无厘头，我也不明白为什么import就会直接出错。 这个时候，直接在主文件中import就无法解决问题了，因为import直接报错。 对我可行的解决方法是找到缺失模块的文件，在该文件中import 比如xadmin.plugins直接import将会出错，于是检查上面报错no module name 部分的信息，找到是哪个文件使用的，在该文件中import xadmin.plugins，便可解决问题。 顺便一体，我找到我的django/myapp/urls.py文件中使用了from xadmin.plugins import ...。 于是直接加上import问题便解决了。 另外网上还提供一种解释及解决方法： pyinstaller无法打包隐式引入的模块（from ... impor ...)，所以需要手动告知 pyinstaller打包这文件。 方法是修改.spec文件。关于这个文件的详细解释可以看一下 官方文档 的详细说明 操作是修改hiddenimports，将需要打包的模块写入。比如 hiddenimport =['rest_framework.authentication','xadmin.plugins'] TemplateDoesNotExist as / 找不到模板文件 解决方法是将文件复制到制定位置，具体需要复制到的路径可以在报错页面内找到 Template-loader postmortem处将提示Django查找文件的路径及顺序。 将需要的文件复制进去便可。 但是这只是对于打包成文件而言可以这么做，而打包成单文件的话，就只能在打 包时将静态文件复制进去。这时就需要用到.spec文件的datas部分。 datas是二元组列表格式，二元组格式为 datas=[ ('需要复制的文件的绝对路径','文件需要复制进打包后的文件的位置'), ('','') ] 这样，在打包后文件将复制到对应位置，解决TemplateDoesNotExist问题。 静态文件找不到(404) 打包之后的django项目，一切正常，就是静态文件找不到。 这里说的静态文件指图片,css,html等。可以尝试上面的添加datas二元组，将静态文件 一并打包进去。具体需要放置的位置就只能根据实际情况放了，我的django是放 在了myapp下面。 django的/admin页面静态文件无法找到 关于这个页面邪门的不行！ 通常，django渲染此页面的css及js会使用python的目录 \\Lib\\site-packages\\django\\contrib\\admin\\static\\admin下的文件。 但是，使用pyinstaller打包时，pyinstaller将会把django的模块复制进包内。 最坑的地方就在这里，我们访问/admin页面所需的静态文件，打包后的项目 不会在python的安装目录里找，也不会在包内的./django模块目录内找。而是会 在你打包前的原目录里的myapp/文件夹里找！！！ 巨坑！解决方法就是将\\Lib\\site-packages\\django\\contrib\\admin\\static\\admin 下的文件全复制到myapp/static/admin/目录下。 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/get-ip.html":{"url":"book/python/get-ip.html","title":"python动态获取公网IP","keywords":"","body":"动态获取本机内网IP # !/usr/bin/env python # coding=utf-8 import socket def get_host_ip()->(str): \"\"\" 获取本机位于局域网中的IP \"\"\" try: ss = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) ss.connect(('8.8.8.8',80)) ip = ss.getsockname()[0] return ip except Exception as e: logger.error(e,exc_info=True) finally: ss.close() By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/python-connection-sqlserver2008.html":{"url":"book/python/python-connection-sqlserver2008.html","title":"python远程连接SqlServer2008R2","keywords":"","body":"Python 远程连接 SQL Server 2008 R2 参考 Django2.1集成xadmin管理后台所遇到的错误集锦，解决填坑 cannot import name 'password_reset_confirm' django2.x报错No module named 'django.core.urlresolvers' 前言 将项目的django升级到2.1之后，xadmin爆炸了，网上资料比较齐全，这里多此一举 整合一下 手动安装xadmin模块 下载 从这里下载 手动安装 $ pip install xadmin-master.zip 如果安装出现问题，可以尝试使用一个空文件重命名为README.rst，替换掉 zip包内的README.rst文件 解决兼容问题 ModuleNotFoundError: No module named 'django.core.urlresolvers' 原因为django2.0将包django.core.urlresolvers重命名为django.urls。 因此，只要将所有引用该包的地方全部改成django.urls，比如 from django.core.urlresolvers import reverse # 改为 from django.urls import reverse ForeignKey引发的错误 将所有使用models.ForeignKey的地方，在后面补上引用外键on_delete=models.CASCADE user = models.ForeignKey(AUTH_USER_MODEL) # 改为 user = models.ForeignKey(AUTH_USER_MODEL,on_delete=models.CASCADE) dashboard.py文件出现参数数量问题 File \"...\\xadmin\\views\\dashboard.py\",line 285 ,in __init__ .... TypeError: __init__() takes 1 positional argument but 6 were given 解决方法： forms.Field.__init__(self, required, widget, label, initial, help_text, *args, **kwargs) # 改为 forms.Field.__init__(self) ImportError: cannot import name 'login' from 'django.contrib.auth.views' # 将 from django.contrib.auth.views import login from django.contrib.auth.views import logout # 改为 from django.contrib.auth import authenticate, login, logout cannot import name 'password_reset_confirm' # 将 from django.contrib.auth.views import password_reset_confirm # 改为 from django.contrib.auth.views import PasswordResetForm ImportError: cannot import name 'QUERY_TERMS' from 'django.db.models.sql.query' # django2.1.1版本将xadmin\\plugins\\filters.py文件中的 from django.db.models.sql.query import LOOKUP_SEP, QUERY_TERMS # 修改为 from django.db.models.sql.query import LOOKUP_SEP, Query # 在Django2.0版本中把 from django.db.models.sql.query import LOOKUP_SEP, QUERY_TERMS # 修改为： from django.db.models.sql.query import LOOKUP_SEP from django.db.models.sql.constants import QUERY_TERMS ModuleNotFoundError: No module named 'django.contrib.formtools' # 卸载旧版本 pip uninstall django-formtools # 安装新版本 pip install django-formtools By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/python-dll.html":{"url":"book/python/python-dll.html","title":"python调用dll","keywords":"","body":"Python 调用DLL 参考 Python的学习（十五）---- 调用windows下DLL详解 python ctype 导入 dll 文件报错 invalid ELF header 有人遇到过吗 python ctypes 调用.dll and .so ctypes模块 加载DLL 加载的时候要根据你将要调用的函数是符合什么调用约定的 stdcall调用约定： 两种加载方式 Objdll = ctypes.windll.LoadLibrary(\"dllpath\") Objdll = ctypes.WinDLL(\"dllpath\") cdesl调用约定： 两种加载方式 Objdll = ctypes.cdll.LoadLibrary(\"dllpath\") Objdll = ctypes.CDLL(\"dllpath\") 其实 windll 和 cdll 分别是WinDLL类和CDLL类的对象 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/python-windows.html":{"url":"book/python/python-windows.html","title":"python注册windows服务","keywords":"","body":"Python注册windows服务 参考 使用Python写Windows Service服务程序 python实现windows Service服务程序 python打包成exe，并将exe注册到windows服务中 Windows Server 2012的服务管理自动化 -启动类型设置，手动启动还是自动启动 代码 网上资料很多，就不多写了 # encoding=utf-8 import win32serviceutil import win32service import win32event import os import logging import inspect import servicemanager class PythonService(win32serviceutil.ServiceFramework): _svc_name_ = \"PythonService\" # 服务名 _svc_display_name_ = \"Python Service Test\" # 服务在windows系统中显示的名称 _svc_description_ = \"This is a python service test code \" # 服务的描述 def __init__(self, args): win32serviceutil.ServiceFramework.__init__(self, args) self.hWaitStop = win32event.CreateEvent(None, 0, 0, None) self.logger = self._getLogger() self.run = True def _getLogger(self): \"\"\" 日志模块 \"\"\" logger = logging.getLogger('[PythonService]') this_file = inspect.getfile(inspect.currentframe()) dirpath = os.path.abspath(os.path.dirname(this_file)) handler = logging.FileHandler(os.path.join(dirpath, \"service.log\")) formatter = logging.Formatter('%(asctime)s %(name)-12s %(levelname)-8s %(message)s') handler.setFormatter(formatter) logger.addHandler(handler) logger.setLevel(logging.INFO) return logger def SvcDoRun(self): import time self.logger.info(\"service is run....\") while self.run: self.logger.info(\"I am runing....\") time.sleep(2) def SvcStop(self): self.logger.info(\"service is stop....\") self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) win32event.SetEvent(self.hWaitStop) self.run = False if __name__=='__main__': if len(sys.argv) == 1: try: evtsrc_dll = os.path.abspath(servicemanager.__file__) servicemanager.PrepareToHostSingle(PythonService) servicemanager.Initialize('PythonService', evtsrc_dll) servicemanager.StartServiceCtrlDispatcher() except win32service.error, details: if details[0] == winerror.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: win32serviceutil.usage() else: win32serviceutil.HandleCommandLine(PythonService) By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/python-str.html":{"url":"book/python/python-str.html","title":"python字符操作","keywords":"","body":"Python3 字符操作 字符串转16字节 a = \"01020C\" # 转为字节串 b = bytes().fromhex(a) # b = b'\\x01\\x02\\x0c' By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/tornado-log.html":{"url":"book/python/tornado-log.html","title":"Tornado日志","keywords":"","body":"Tornado 日志 参考 https://cuiqingcai.com/6080.html https://codeday.me/bug/20190216/634978.html https://www.jianshu.com/p/8c74a3d87567 代码参考 # !/usr/bin/env python # codig=utf-8 import tornado.ioloop import tornado.options import tornado.httpserver import pymongo import motor.motor_tornado from tornado.log import enable_pretty_logging import logging from application import application from tornado.options import define, options # 日志 # 定义logger并起名server用于日志配置共享 logger = logging.getLogger(\"server\") logger.setLevel(level=logging.INFO) handler = logging.handlers.RotatingFileHandler(\"/var/log/tornado/tornado.log\", mode=\"a\", maxBytes=1048000, backupCount=10, encoding=\"utf-8\") formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') handler.setFormatter(formatter) # tornado的日志记录器，access是web访问信息 app_log = logging.getLogger(\"tornado.application\") access_log = logging.getLogger(\"tornado.access\") gen_log = logging.getLogger(\"tornado.general\") enable_pretty_logging() app_log.addHandler(handler) access_log.addHandler(handler) gen_log.addHandler(handler) logger.addHandler(handler) define(\"port\",default = 8000, help = \"run on the given port\", type = int) class LogFormatter(tornado.log.LogFormatter): \"\"\" 重写tornado日志模块的格式 \"\"\" def __init__(self): super(LogFormatter, self).__init__( fmt='%(color)s[%(asctime)s %(filename)s:%(funcName)s:%(lineno)d %(levelname)s]%(end_color)s %(message)s', datefmt='%Y-%m-%d %H:%M:%S' ) def main(): tornado.options.parse_command_line() # [i.setFormatter(LogFormatter()) for i in logging.getLogger().handlers] http_server = tornado.httpserver.HTTPServer(application) http_server.listen(options.port) print(\"runing at http://127.0.0.1:{}\".format(options.port)) print(\"Quite the server with Control-C\") http_server.start(0) # 为每个子进程创建一个MotorClient application.settings['db'] = motor.motor_tornado.MotorClient(\"localhost\",27017).testdb tornado.ioloop.IOLoop.instance().start() if __name__ == \"__main__\": main() 思路 tornado是使用logging模块来进行日志管理的，所以只需要添加一个logging的 处理器(handler)，将tornado自己的三个处理器tornado.application tornado.access tornado.access获取到之后为其 addHandler 自己的处理器，就可以实现在 tornado有输出的同时将输出一份到文件 重写日志格式 tornado的日志格式是可以修改的。参考上面代码 class LogFormatter(tornado.log.LogFormatter): \"\"\" 重写tornado日志模块的格式 \"\"\" def __init__(self): super(LogFormatter, self).__init__( fmt='%(color)s[%(asctime)s %(filename)s:%(funcName)s:%(lineno)d %(levelname)s]%(end_color)s %(message)s', datefmt='%Y-%m-%d %H:%M:%S' ) def main(): ......... [i.setFormatter(LogFormatter()) for i in logging.getLogger().handlers] ......... By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/python/tornado-tcpserver.html":{"url":"book/python/tornado-tcpserver.html","title":"Tornado TCPServer","keywords":"","body":"Tornado TCPServer 参考 https://cuiqingcai.com/6080.html https://codeday.me/bug/20190216/634978.html https://www.jianshu.com/p/8c74a3d87567 代码参考 # !/usr/bin/env python # codig=utf-8 import tornado.ioloop import tornado.options import tornado.httpserver import pymongo import motor.motor_tornado from tornado.log import enable_pretty_logging import logging from application import application from tornado.options import define, options # 日志 # 定义logger并起名server用于日志配置共享 logger = logging.getLogger(\"server\") logger.setLevel(level=logging.INFO) handler = logging.handlers.RotatingFileHandler(\"/var/log/tornado/tornado.log\", mode=\"a\", maxBytes=1048000, backupCount=10, encoding=\"utf-8\") formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') handler.setFormatter(formatter) # tornado的日志记录器，access是web访问信息 app_log = logging.getLogger(\"tornado.application\") access_log = logging.getLogger(\"tornado.access\") gen_log = logging.getLogger(\"tornado.general\") enable_pretty_logging() app_log.addHandler(handler) access_log.addHandler(handler) gen_log.addHandler(handler) logger.addHandler(handler) define(\"port\",default = 8000, help = \"run on the given port\", type = int) class LogFormatter(tornado.log.LogFormatter): \"\"\" 重写tornado日志模块的格式 \"\"\" def __init__(self): super(LogFormatter, self).__init__( fmt='%(color)s[%(asctime)s %(filename)s:%(funcName)s:%(lineno)d %(levelname)s]%(end_color)s %(message)s', datefmt='%Y-%m-%d %H:%M:%S' ) def main(): tornado.options.parse_command_line() # [i.setFormatter(LogFormatter()) for i in logging.getLogger().handlers] http_server = tornado.httpserver.HTTPServer(application) http_server.listen(options.port) print(\"runing at http://127.0.0.1:{}\".format(options.port)) print(\"Quite the server with Control-C\") http_server.start(0) # 为每个子进程创建一个MotorClient application.settings['db'] = motor.motor_tornado.MotorClient(\"localhost\",27017).testdb tornado.ioloop.IOLoop.instance().start() if __name__ == \"__main__\": main() 日志 思路 tornado是使用logging模块来进行日志管理的，所以只需要添加一个logging的 处理器(handler)，将tornado自己的三个处理器tornado.application tornado.access tornado.access获取到之后为其 addHandler 自己的处理器，就可以实现在 tornado有输出的同时将输出一份到文件 重写日志格式 tornado的日志格式是可以修改的。参考上面代码 class LogFormatter(tornado.log.LogFormatter): \"\"\" 重写tornado日志模块的格式 \"\"\" def __init__(self): super(LogFormatter, self).__init__( fmt='%(color)s[%(asctime)s %(filename)s:%(funcName)s:%(lineno)d %(levelname)s]%(end_color)s %(message)s', datefmt='%Y-%m-%d %H:%M:%S' ) def main(): ......... [i.setFormatter(LogFormatter()) for i in logging.getLogger().handlers] ......... By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/docker/readme.html":{"url":"book/docker/readme.html","title":"Docker","keywords":"","body":"By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:58:12 "},"book/docker/docker.html":{"url":"book/docker/docker.html","title":"Docker","keywords":"","body":"DOCKER 参考： Docker DockerHub 跟陈sir一起玩转docker卷 一 docker学习5--docker数据卷(volume) docker中宿主机与容器（container）互相拷贝传递文件的方法 删除私有仓库镜像 参考 Docker私有仓库搭建及镜像删除 docker私有仓库删除image docker 查询或获取私有仓库(registry)中的镜像 Docker Registry之删除镜像、垃圾回收 服务器配置 服务器上的register容器需要修改配置文件，允许其删除镜像。 配置文件名位config.yml 因为我们要修改这个配置文件并以此文件来允许register容器，所以我们物理机 上必然就没有这个文件，可以先运行一次register容器，然后从其中拷出这个 配置文件做修改 $ docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry 561d1e831f8376684d7d82d3616c6d90135c785cdbfff3fd296a8f4a67be1d70 $ docker cp 561:/etc/docker/registry/config.yml ./ $ vim config.yml 打开文件后在其中找到 storage: cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registry 加入一句配置： storage: delete: enabled: true cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registry 再启动容器便可删除仓库镜像 $ docker run -d -v /home/jyt/config.yml:/etc/docker/registry/config.yml \\ > -v /opt/data/registry:/var/lib/registry \\ > -p 5000:5000 --restart=always --name registry registry 6f425cd3aadb256e25cc37bad0d49b3d9fa614901dd0e6ddc7c121806b9b1b72 删除镜像 查询仓库现有镜像 $ curl server:port/v2/_catalog {\"repositories\":[\"alpine\",\"ubuntu\"]} 查询指定镜像在仓库中的现有版本 $ curl server:port/v2/ubuntu/tags/list {\"name\":\"ubuntu\",\"tags\":[\"18.04\"]} 查询指定镜像版本的sha码 $ curl --header \"Accept: application/vnd.docker.distribution.manifest.v2+json\" -I -XGET server:port/v2/ubuntu/manifests/18.04 HTTP/1.1 200 OK Content-Length: 1150 Content-Type: application/vnd.docker.distribution.manifest.v2+json Docker-Content-Digest: sha256:be159ff0e12a38fd2208022484bee14412680727ec992680b66cdead1ba76d19 Docker-Distribution-Api-Version: registry/2.0 Etag: \"sha256:be159ff0e12a38fd2208022484bee14412680727ec992680b66cdead1ba76d19\" X-Content-Type-Options: nosniff Date: Thu, 21 Feb 2019 05:20:54 GMT 根据sha码删除镜像 $ curl -XDELETE server:port/v2/ubuntu/manifests/sha256:be159ff0e12a38fd2208022484bee14412680727ec992680b66cdead1ba76d19 执行这个操作没有返回结果的，linux的哲学“没有消息，就是好消息” 但这个时候仅仅只是删除了一个“标签”，再次查询仓库，会发现镜像名字任然 在，而查询版本时就找不到指定版本 $ curl server:port/v2/ubuntu/tags/list {\"name\":\"ubuntu\",\"tags\":null} 释放空间 想要释放空间只能进服务器的register容器内操作了（以下操作在服务器上进行） $ docker container ls 6f425cd3aadb registry \"/entrypoint.sh /etc…\" About an hour ago Up About an hour 0.0.0.0:5000->5000/tcp registry $ docker exec -it 6f4 /bin/sh / # cd /var/lib/registry / # du -sh 33.8M 这里可以看到，存储镜像的文件夹大小，33.8M。 这里有个疑问，上传的镜像大小和仓库存储镜像的文件夹大小差太多，存储镜像的文件小很多 registry garbage-collect /etc/docker/registry/config.yml 以上，便完成了网上所谓的镜像删除。 再次尝试之后发现，将一个镜像删除之后再次push上去之后就无法pull下来了 $ docker pull server:port/ubuntu:18.04 Error response from daemon: manifest for 139.199.9.116:5000/ubuntu:18.04 not found 错误 启动register错误 参考：docker端口映射或启动容器时报错Error response from daemon: driver failed programming external connectivity on endpoint quirky_allen docker: Error response from daemon: driver failed programming external connectivity on endpoint romantic_sanderson (12565e44485be0ef9d5c282 e325d76dc4e8a1e38f71f2764fbf83bbcb18e27be): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 5000 -j DNAT --to-destination 172.17.0.2:5000 ! -i docker0: iptables: No chain/target/match by that name. (exit status 1)). 解决方法：重启docker $ systemctl restart docker 端口占用 在启动容器时报错 Error response from daemon: driver failed programming external connectivity on endpoint redis (6c89629a558b666e5fba1c3ad27d6de3c4b341ee1005dae9ab3ec7b797cfdf1d): Error starting userland proxy: listen tcp 0.0.0.0:6379: bind: address already in use Error: failed to start containers: redis 原因很明显，端口被使用了，解决方法就是释放该端口 $ lsof -i:6379 很尴尬的事情发生了，lsof没有输出任何内容，这代表没有任何进程正在使用 这个端口，但是这个端口又切切实实的被占用着。对于lsof的作用可能需要重新 认知一下了，但现在不是搞这个的时候。 好在我们知道这个端口默认是redis的服务在使用，于是 $ sudo service redis-server stop 停止redis服务间接实现释放该端口 启动容器命令参考 postgresql $ docker run -dit -p 5432:5432 --name postgresql \\ > --mount source=postgresql,target=/var/lib/postgresql \\ > -u postgres jyt:v11\\ > /usr/lib/postgresql/9.3/bin/postgres \\ > -D /var/lib/postgresql/9.3/main \\ > -c config_file=/etc/postgresql/9.3/main/postgresql.conf 参考:使用docker部署PostgreSQL数据库 redis $ docker run -dit --network jyt-net \\ > --mount source=redis,target=/var/lib/redis \\ > -p 6379:6379 \\ > --name redis jyt:v11 \\ > /usr/bin/redis-server 参考：Docker 安装 Redis redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开 redis持久化配置 在docker中部署postgresql启动错误 1、 web_1 | django.db.utils.OperationalError: FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"postgres\", SSL on web_1 | FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"postgres\", SSL off web_1 | db-com | 2019-02-26 12:11:43.925 CST [19] postgres@postgres FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"p ostgres\", SSL on db-com | 2019-02-26 12:11:43.928 CST [20] postgres@postgres FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"p ostgres\", SSL off 如上提示，由于数据库身份验证失败导致 由于首次安装postgresql时会产生一个postgres的Unix用户和一个postgres 的数据库用户，Unix用户的密码可以不管，但由于没有设置密码，要执行postgres 命令必须切换到postgres用户下。而数据库用户postgres没有设置密码就会 导致外部进程无法连接，因为该数据库用户没有密码，连接时不给密码就会提示 2019-02-26 14:16:11.230 CST [19] postgres@postgres FATAL: password authentication failed for user \"postgres\" 2019-02-26 14:16:11.230 CST [19] postgres@postgres DETAIL: User \"postgres\" has no password assigned. Connection matched pg_hba.conf line 95: \"host all all 0.0.0.0/0 md5\" 2019-02-26 14:16:11.233 CST [20] postgres@postgres FATAL: password authentication failed for user \"postgres\" 2019-02-26 14:16:11.233 CST [20] postgres@postgres DETAIL: User \"postgres\" has no password assigned. Connection matched pg_hba.conf line 95: \"host all all 0.0.0.0/0 md5\" 而随便给个密码又会 FATAL: password authentication failed for user \"postgres\" 解决方法就是修改数据库用户postgres的密码，切换到Unix的postgres用户下执行 $ su postgres $ psql --command \" ALTER USER postgres WITH PASSWORD '123456';\" 在Dockerfile中则是 USER postgres RUN /etc/init.d/postgresql restart \\ && psql --command \" ALTER USER postgres WITH PASSWORD '123456';\" \\ && /etc/init.d/postgresql stop 2、 db-com | 2019-02-26 13:41:56.227 CST [11] LOG: could not open temporary statistics file \"/var/run/postgresql/10-main.pg_stat_tmp/global.tmp\": No such file or directory 按错误日志，创建该目录，并将所有者改为postgres $ mkdir -p /var/run/postgresql/10-main.pg_stat_tmp \\ $ chown -R postgres:postgres /var/run/postgresql/10-main.pg_stat_tmp 3、 db-com | 2019-02-26 13:50:14.828 CST [1] LOG: listening on IPv4 address \"127.0.0.1\", port 5432 db-com | 2019-02-26 13:50:14.828 CST [1] LOG: could not bind IPv6 address \"::1\": Cannot assign requested address db-com | 2019-02-26 13:50:14.828 CST [1] HINT: Is another postmaster already running on port 5432? If not, wait a few seconds and retry. db-com | 2019-02-26 13:50:14.831 CST [1] LOG: listening on Unix socket \"/var/run/postgresql/.s.PGSQL.5432\" db-com | 2019-02-26 13:50:14.863 CST [6] LOG: database system was shut down at 2019-02-26 12:28:48 CST db-com | 2019-02-26 13:50:14.881 CST [1] LOG: database system is ready to accept connections 但是web服务连接时却出现 web_1 | django.db.utils.OperationalError: could not connect to server: Connection refused web_1 | Is the server running on host \"db\" (172.18.0.3) and accepting web_1 | TCP/IP connections on port 5432? 这个问题比较微妙，我目前已知的原因有三个，目前正在接触的web项目为django， 所以此处列出django的示例，提供参考 1、postgresql的postgresql.conf 在该文件中找到 # - Connection Settings - listen_addresses = '127.0.0.1' # what IP address(es) to listen on; # comma-separated list of addresses; # defaults to 'localhost'; use '*' for all # (change requires restart) port = 5432 # (change requires restart) max_connections = 100 # (change requires restart) # superuser_reserved_connections = 3 # (change requires restart) 将listen_addresses改为listen_addresses = '0.0.0.0' 这是由于，在容器中启动时127.0.0.1总是指向容器本身，导致无法监听来自外部其他 容器的访问。 2、postgresql的pg_hba.conf 在该文件中中找到 # Database administrative login by Unix domain socket local all postgres peer # TYPE DATABASE USER ADDRESS METHOD # \"local\" is for Unix domain socket connections only local all all trust # IPv4 local connections: host all all 127.0.0.1/32 md5 # IPv6 local connections: host all all ::1/128 md5 保证和上面代码内容相同，其中trust在较新的版本中可以使用peer代替 3、django的配置文件settings.py 找到连接数据库的配置内容 DATABASES = { 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'postgres', 'USER':'postgres', 'PASSWORD':'123456', 'HOST':'db', 'PORT':'5432', } 其中'HOST':'db'需要指向具体容器的服务名称，原因和上面一样，如果使用 localhost将会一直指向容器本身导致无法正确访问数据库。也就是django会在 当前容器下查找数据库服务，但是数据库服务却在其他容器提供。 由于我时使用docker-compose来管理容器，而compose则是项目和服务 的概念，这里稍微转换一下 compose将数个容器提供的服务整个成一起，称为一个项目，而每个容器本身提供服务， 故将容器称为服务 如果没有使用compose的话，比如直接使用docker网桥服务来连接容器将的 通信，则这里的HOSTS则指向该容器在网桥中的IP，可以使用 docker inspect 来查看具体容器的IP 4、 PermissionError: [Errno 13] Permission denied: '/code/jimi_commd.log' 用更高的用户权限或者修改相关文件的权限和所有者 5、 no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"postgres\", SSL on 将172.18.0.4添加进pg_hba.conf echo \"host all all 172.18.0.4/16 md5\" >> pg_hba.conf 启动redis错误 修改配置文件redis.conf,找到 bind 127.0.0.1 # protected-mode yes 改为 # bind 127.0.0.1 protected-mode no 注释掉bind而不是改成0.0.0.0就能允许所有主机连接 protected-mode no 则是关闭安全模式 修改完这两部之后需要重启redis并执行 $ redis-server --protected-mode no 使配置生效，否则会一直提示 redis.exceptions.ResponseError: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. 3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside. 解决错误参考： docker-compose error # 55 PostgreSQL学习第五篇--监听地址及端口修改 如何设置PostgreSQL允许被远程访问 如何获取 docker 容器(container)的 ip 地址 Postgresql: password authentication failed for user “postgres” Postgres 9.5-main.pg_stat_tmp: No such file or directory PostgreSQL script fails # 2 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/docker/harbor.html":{"url":"book/docker/harbor.html","title":"harbor","keywords":"","body":"Harbor 参考 HARBOR Installation and Configuration Guide Configuring Harbor with HTTPS Access User Guide Docker 企业级私有镜像仓库 Harbor 部署 私有仓库高级配置 CentOS7搭建Harbor镜像仓库及https处理 安装Harbor 在线安装 $ wget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-online-installer-v1.7.4.tgz $ tar xvf harbor-online-installer-v1.7.4.tgz 离线安装 $ wget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.4.tgz $ tar xvf harbor-offline-installer-v1.7.4.tgz Openssl自行签发证书 假设需要签署证书的域名为yourdoain.com 正式部署请务必将其替换成自己的域名 获得证书授权 openssl genrsa -out ca.key 4096 openssl req -x509 -new -nodes -sha512 -days 3650 \\ -subj \"/C=TW/ST=Taipei/L=Taipei/O=example/OU=Personal/CN=yourdomain.com\" \\ -key ca.key \\ -out ca.crt 获得服务器证书 1) 创建自己的私钥 openssl genrsa -out yourdomain.com.key 4096 2) 生成证书签名请求 openssl req -sha512 -new \\ -subj \"/C=TW/ST=Taipei/L=Taipei/O=example/OU=Personal/CN=yourdomain.com\" \\ -key yourdomain.com.key \\ -out yourdomain.com.csr 3) 生成注册表主机的证书 cat > v3.ext [alt_names] DNS.1=yourdomain.com DNS.2=yourdomain DNS.3=hostname EOF 操作这步之后当前目录下会出现v3.ext文件，上面语法中的cat > v3.ext 可以参考shell 配置和安装 1) 配置服务器证书和Harbor秘钥 将上面步骤得到的yourdomain.com.crt和yourdomain.com.key文件复制到 /data/cert/,用于Harbor配置文件找到证书的路径 cp yourdomain.com.crt /data/cert/ cp yourdomain.com.key /data/cert/ 3) 为docker配置服务器证书，秘钥和CA Docker守护程序将.crt文件解释为CA证书，将.cert文件解释为客户端证书。 将服务器转换yourdomain.com.crt为yourdomain.com.cert： openssl x509 -inform PEM -in yourdomain.com.crt -out yourdomain.com.cert Delpoy yourdomain.com.cert，yourdomain.com.key和ca.crtDocker： cp yourdomain.com.cert /etc/docker/certs.d/yourdomain.com/ cp yourdomain.com.key /etc/docker/certs.d/yourdomain.com/ cp ca.crt /etc/docker/certs.d/yourdomain.com/ 以下说明了使用自定义证书的配置： /etc/docker/certs.d/ └── yourdomain.com:port ├── yourdomain.com.cert 3) 配置Harbor 编辑文件harbor.cfg，更新主机名和协议，并更新ssl_cert和ssl_cert_key: set hostname hostname = yourdomain.com:port set ui_url_protocol ui_url_protocol = https ...... The path of cert and key files for nginx, they are applied only the protocol is set to https ssl_cert = /data/cert/yourdomain.com.crt ssl_cert_key = /data/cert/yourdomain.com.key 为Harbor生成配置文件： ./prepare 如果Harbor已在运行，请停止并删除现有实例。您的图像数据保留在文件系统中 docker-compose down -v 最后，重启港湾： docker-compose up -d 为Harbor设置HTTPS后，您可以通过以下步骤进行验证： 打开浏览器并输入地址：https：//yourdomain.com。它应该显示Harbor的用户界面。 请注意，即使我们通过自签名CA签署证书并将CA部署到上述位置，某些浏览器仍可能出于安全原因显示有关证书颁发机构（CA）未知的警告。这是因为自签名CA本质上不是受信任的第三方CA. 您可以自己将CA导入浏览器以解决警告。 在具有Docker守护程序的计算机上，请确保https://yourdomain.com的选项“-insecure-registry” 不存在。 如果您将nginx端口443映射到另一个端口，那么您应该创建目录/etc/docker/certs.d/yourdomain.com:port（或您的注册表主机IP：端口）。然后运行任何docker命令来验证设置，例如 docker login yourdomain.com 如果您已将nginx 443端口映射到另一个端口，则需要将端口添加到登录，如下所示： docker login yourdomain.com:port 客户端 如果想在客户端拉取openssl自签署证书的仓库时可能会遇到 Error response from daemon: Get https://youserver.com/v2/: x509: certificate signed by unknown authority 即证书未受信任，解决方法有两个 1) 手动信任该网站 修改/etc/docker/daemon.json文件将域名加入 { \"registry-mirror\": [\"https://registry.docker-cn.com\"], \"insecure-registries\": [\"youserver.com\"] } 2) 在客户端安装证书 cp yourdomain.com.crt /usr/local/share/ca-certificates/yourdomain.com.crt update-ca-certificates 如果还是不行，则修改hosts文件，将域名指向IP $ echo '0.0.0.0 youserver.com' >> /etc/hosts By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/docker/harbor2.html":{"url":"book/docker/harbor2.html","title":"harbor2","keywords":"","body":"Harbor 前言 一时踩坑一时爽，一直踩坑电脑会坏掉 非常感谢帮助我的大佬们，记下大佬的群号:774607973 登录时hostname错误 Error response from daemon: Get https://server.top/v2/: Get https://server.com:80/service/token?account=admin&client_id=docker&offline_token=true&service=harbor-registry: http: server gave HTTP response to HTTPS client 前面`.top`后面变成`.com`，`hostname`填错了。解决方法： 打开`Harbor`的配置文件`harbor.cfg`，找到 The IP address or hostname to access admin UI and registry service. DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients. DO NOT comment out this line, modify the value of \"hostname\" directly, or the installation will fail. hostname = reg.mydomain.com hostname = server.com 将`.com`改为正确的。之后，尤其重要的个步骤是`为Harbor生成配置文件` $ ./prepare 之后再重启`docker-compose` # nginx不停重启 启动`Harbor`之后，执行`docker-compose ps`发现`nginx`在不停的重启。 由于我的日志驱动有问题，就从日志文件`/var/log/harbor/proxy.log`找到部分 问题。 Apr 1 19:04:52 172.25.0.1 proxy[22610]: nginx: [emerg] PEM_read_bio_X509_AUX(\"/etc/nginx/cert/server.top.crt\") failed (SSL: error:25066067:DSO support routine s:DLFCN_LOAD:could not load the shared library:filename (libz.so): libz.so: cannot open shared object file: No such file or directory error:25070067:DSO support routines:DSO_load:could not load the shared library error:0906D06C:PEM routines:PEM_read_bio:no start line) 没找到ssl的.crt文件导致，于是我将文件复制到了指定路径/etc/nginx/cert/ 但是，没能解决问题，后来大佬又指点了我，我的.crt文件格式不对，才想起 由于我从阿里云上申请的免费证书后缀是.pem我就使用opssl转换成了.crt， 造成格式不对。其实不用转，直接将.pem的后缀改成.crt就行了 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/v2ray/v2ray.html":{"url":"book/v2ray/v2ray.html","title":"V2ray","keywords":"","body":"V2ray 参考 V2ray官网 github项目地址 栋叔整理的博客 安装 需要切换到root用户下操作 bash 如果不行的话就试一下 wget https://install.direct/go.sh bash go.sh 如果在执行一键脚本时下载v2ray失败（提示连接超时），请检查网络，换个运营商网络 配置文件 服务端 { \"log\": { \"access\": \"/var/log/v2ray/access.log\", \"error\": \"/var/log/v2ray/error.log\", \"loglevel\": \"debug\" }, \"inbounds\": [{ \"port\": 10001, \"protocol\": \"vmess\", \"settings\": { \"clients\": [ { \"id\": \"12345678-1234-1234-1234-123456789012\", \"level\": 1, \"alterId\": 64 } ] }, \"StreamSettings\":{ \"network\": \"kcp\", \"kcpSettings\":{ \"mtu\": 1350, \"tti\": 50, \"uplinkCapacity\": 15, \"downlinkCapacity\": 100, \"congestion\": true, \"readBufferSize\": 5, \"writeBufferSize\": 5, \"header\": { \"type\": \"wechat-video\" } } }, \"tag\": \"clip\" }], \"outbounds\": [{ \"protocol\": \"freedom\", \"settings\": {} }, { \"tag\": \"blocked\", \"protocol\": \"blackhole\", \"settings\": {} }], \"routing\": { \"rules\": [ { \"type\": \"field\", \"domain\": [\"geosite.dat:category-ads\", \"geosite.dat:category-ads-all\", \"geosite.dat:cn\", \"geosite.dat:google\", \"geosite.dat:facebook\", \"geosite.dat:geolocation-cn\", \"geosite.dat:geolocation-!cn\", \"geosite.dat:speedtest\", \"geosite.dat:tld-cn\" ], \"ip\": [\"geoip:private\"], \"outboundTag\": \"blocked\" } ] } } 客户端配置 { \"log\": { \"access\": \"\", \"error\": \"\", \"loglevel\": \"warning\" }, \"inbound\": { \"port\": 1080, \"listen\": \"127.0.0.1\", \"protocol\": \"socks\", \"domainOverride\": [ \"tls\", \"http\" ], \"settings\": { \"auth\": \"noauth\", \"udp\": true, \"ip\": \"127.0.0.1\", \"clients\": null }, \"streamSettings\": null }, \"outbound\": { \"tag\": \"agentout\", \"protocol\": \"vmess\", \"settings\": { \"vnext\": [ { \"address\": \"123.123.123.123\", \"port\": 10001, \"users\": [ { \"id\": \"12345678-1234-1234-1234-123456789012\", \"alterId\": 64, \"email\": \"t@t.tt\", \"security\": \"aes-128-gcm\" } ] } ], \"servers\": null }, \"streamSettings\": { \"network\": \"kcp\", \"security\": \"\", \"tlsSettings\": null, \"tcpSettings\": null, \"kcpSettings\": { \"mtu\": 1350, \"tti\": 50, \"uplinkCapacity\": 12, \"downlinkCapacity\": 100, \"congestion\": false, \"readBufferSize\": 2, \"writeBufferSize\": 2, \"header\": { \"type\": \"wechat-video\", \"request\": null, \"response\": null } }, \"wsSettings\": null, \"httpSettings\": null }, \"mux\": { \"enabled\": true } }, \"inboundDetour\": null, \"outboundDetour\": [ { \"protocol\": \"freedom\", \"settings\": { \"response\": null }, \"tag\": \"direct\" }, { \"protocol\": \"blackhole\", \"settings\": { \"response\": { \"type\": \"http\" } }, \"tag\": \"blockout\" } ], \"dns\": { \"servers\": [ \"8.8.8.8\", \"8.8.4.4\", \"localhost\" ] }, \"routing\": { \"strategy\": \"rules\", \"settings\": { \"domainStrategy\": \"IPIfNonMatch\", \"rules\": [ { \"type\": \"field\", \"port\": null, \"outboundTag\": \"direct\", \"ip\": [ \"0.0.0.0/8\", \"10.0.0.0/8\", \"100.64.0.0/10\", \"127.0.0.0/8\", \"169.254.0.0/16\", \"172.16.0.0/12\", \"192.0.0.0/24\", \"192.0.2.0/24\", \"192.168.0.0/16\", \"198.18.0.0/15\", \"198.51.100.0/24\", \"203.0.113.0/24\", \"::1/128\", \"fc00::/7\", \"fe80::/10\" ], \"domain\": null } ] } } } 特别注意 服务器和客户端时间差不能超过1分钟 配置文件说明 \"log\": {}. 日志文件输入配置 \"inbounds\":[] 数组，入站连接配置 \"outbounds\":[] 数组，出站连接配置 routing:{} 路由配置 inbounds port 端口，接的格式如下： 整型数值: 实际的端口号。 环境变量: 以\"env:\"开头，后面是一个环境变量的名称，如\"env:PORT\"。V2Ray 会以字符串形式解析这个环境变量。 字符串: 可以是一个数值类型的字符串，如\"1234\"；或者一个数值范围，如\"5-10\"表示端口 5 到端口 10 这 6 个端口。 当只有一个端口时，V2Ray 会在此端口监听入站连接。当指定了一个端口范围时，取决于allocate设置。 protocol 连接协议的名称，可选值有： Blackhole Dokodemo-door Freedom HTTP MTProto Shadowsocks Socks VMess settings 具体协议的配置内容(本文只介绍Vmess) clients VMess 用户的主 ID，linux下可使用以下命令生成 cat /proc/sys/kernel/random/uuid alterId 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 4。不指定的话，默认值是 0。最大值 65535。这个值不能超过服务器端所指定的值。 level 用户等级 StreamSettings 底层传输配置 network 数据流所使用的网络类型，默认值为 \"tcp\"; 可选值有： tcp kcp ws http domainsocket quic kcpSettings 当前连接的 mKCP 配置，仅当此连接使用 mKCP 时有效。 mtu: number 最大传输单元（maximum transmission unit），请选择一个介于 576 - 1460 之间的值。默认值为 1350。 tti: number 传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。请选译一个介于 10 - 100 之间的值。默认值为 50。 uplinkCapacity: number 上行链路容量，即主机发出数据所用的最大带宽，单位 MB/s，默认值 5。注意是 Byte 而非 bit。可以设置为 0，表示一个非常小的带宽。 downlinkCapacity: number 下行链路容量，即主机接收数据所用的最大带宽，单位 MB/s，默认值 20。注意是 Byte 而非 bit。可以设置为 0，表示一个非常小的带宽。 congestion: true | false 是否启用拥塞控制，默认值为 false。开启拥塞控制之后，V2Ray 会自动监测网络质量，当丢包严重时，会自动降低吞吐量；当网络畅通时，也会适当增加吞吐量。 readBufferSize: number 单个连接的读取缓冲区大小，单位是 MB。默认值为 2。 writeBufferSize: number 单个连接的写入缓冲区大小，单位是 MB。默认值为 2。 header: HeaderObject 数据包头部伪装设置，可选值有： |伪装类型|说明| |---|----| |\"none\"| 默认值，不进行伪装，发送的数据是没有特征的数据包。| |\"srtp\"| 伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。| |\"utp\"| 伪装成 uTP 数据包，会被识别为 BT 下载数据。| |\"wechat-video\"| 伪装成微信视频通话的数据包。| |\"dtls\"| 伪装成 DTLS 1.2 数据包。| |\"wireguard\"| 伪装成 WireGuard 数据包。(并不是真正的 WireGuard 协议)| tag 此入站连接的标识，用于在其它的配置中定位此连接。当其不为空时，其值必须在所有tag中唯一。 开启端口 配置好之后要将服务器的端口打开才能正常使用 firewall-cmd --zone=public --add-port=8963/tcp --permanent firewall-cmd --zone=public --add-port=8963/udp --permanent 重启端口 firewall-cmd --reload 查看端口 firewall-cmd --list-ports 注意： 各个供应商可能会使用外部防火墙，导致系统开启端口缺仍然不通。 需要根据各种服务商规则进行配置 管理V2ray 启动 systemctl start v2ray 停止 systemctl stop v2ray 重启 systemctl restart v2ray 查看状态 systemctl status v2ray shadowsocksr 使用shadowsocksr来搭建梯子（简称ss），搭建ss梯子很方便，网上教程也 多，在服务器上也能够很简单的搭建好ss 我选用的服务器是centos，和ubuntu在linux上是不同分支，所以很多地方会 有所差别 首先，安装wget来下载东西 yum install wget -y 安装好之后使用wget下载ss的相关内容，具体是啥给忘了，总之下载就对了 wget -N --nocheck-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh&& chmod +x ssr.sh && bash ssr.sh # 如果这个不能下载的话就试一下 wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh&& chmod +x ssr.sh && bash ssr.sh 下载好之后就会自己安装好，根据提示操作就可以了 输入数字 1 开始安装 要求输入需要使用的端口，这个端口不要占用系统要用的端口就行了， 这边使用8963这个端口 之后会提示输入密码，这个密码会作为连接ss的密码 之后回要求选择加密方式，我选择了chacha20，使用这个端口的话需要安装 libsodum 之后回要求选择协议插件，这个如果是要搭建更安全的ssr的话就要设置，但是 很多ss客户端不支持使用，所以用起来会有所问题。因为并没有什么特别机密的 东西，就是用来查资料所以就不管这个来，输入默认的选项就行origin 因为不是原版的，而是使用了网上改良版，会提示是否要安装兼容原版的插件 ，全部选no就好啦 之后混淆插件，一样不需要，选择plain 之后就会开始安装ss，耐心等待就可以啦 完成安装之后可以使用锐速加速或则谷歌bbr，我使用的是bbr 搭建谷歌BBR加速 wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 有提示需要就输入 y 最后重启服务器就可以来，reboot By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/supervisor/readme.html":{"url":"book/supervisor/readme.html","title":"supervisor","keywords":"","body":"By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:58:12 "},"book/supervisor/supervisor.html":{"url":"book/supervisor/supervisor.html","title":"supervisor","keywords":"","body":"supervisor 简介 Supervisor是一个客户端/服务器系统，允许其用户在类UNIX操作系统上控制许多进程。 注意： Supervisor是使用python2进行开发，运行依赖于python2； 故要求默认python版本必须为python2 使用以下命令可的到类似输出 $ python version Python 2.7.5 建议切换到 root 用户操作 $ sudo su 安装 sudo pip install supervisor 配置 配置文件有两种,一般放在/etc/supervisor/目录下 supervisor └ supervisord程序的启动配置文件 *.conf └ supervisor通过该配置文件管理进程(启动/关闭)supervisor.conf ```conf ; supervisor config file [unix_http_server] file=/var/run/supervisor.sock ; (the path to the socket file) chmod=0700 ; sockef file mode (default 0700) [supervisord] logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log) pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid) childlogdir=/var/log/supervisor ; ('AUTO' child log dir, default $TEMP) ; the below section must remain in the config file for RPC ; (supervisorctl/web interface) to work, additional interfaces may be ; added by defining them in separate rpcinterface: sections [rpcinterface:supervisor] supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket ; The [include] section can just contain the \"files\" setting. This ; setting can list multiple files (separated by whitespace or ; newlines). It can also contain wildcards. The filenames are ; interpreted as relative to this file. Included files cannot ; include files themselves. [include] files = /etc/supervisor/conf.d/*.conf 也可以使用以下指令生成配置文件 echo_supervisord_conf > /etc/supervisord.conf # *.conf [program:django] directory=/root/gpsenv/gpsenv command=/root/gpsenv/gpsenv/bin/python /root/gpsenv/manage.py runserver 0.0.0.0:8000 autostart=true autorestart=true startretries=10 redirect_stderr=true stdout_logfile=/var/log/supervisor/django.log environment=ASPNETCORE_ENVIRONMENT=\"Development\" # 其他文件创建 sudo mkdir supervisord sudo touch supervisord/supervisord.log sudo touch supervisord/stdout.log # 启动supervisor supervisord -c /etc/supervisor/supervisord.conf 具体路径请根据实际`supervisord.conf`文件所在位置进行配置 # 管理supervisor 1、查看状态 supervisorctl status 2、停止一个进程 supervisorctl stop 3、启动一个进程 supervisorctl start 4、重启一个进程 supervisorctl restart 5、删除一个进程 supervisorctl remove 6、更新一个进程的配置文件 supervisorctl update `` `为进程名，请按需替换 报错 使用python3启动supervisor 系统python环境不是python2的话，由于supervisor是python2的环境下运行， 如果版本不对将会导致启动错误。 可以通过修改/etc/bin/supervisord和/etc/bin/supervisorctl的启动版本来解决 先找到这两个文件，通过find命令查找 find / |grep supervisorctl find / |grep supervisord 找打文件，一般都在/etc/bin/目录下可以看到这两个文件 直接进入修改 vim /etc/bin/supervisord vim /etc/bin/supervisorctl 进入文件会看到第一行有 # !/usr/bin/python 将其修改为 # !/usr/bin/python2 便可使用python2环境启动supervisor 文件权限报错 保证几个文件夹的文件有足够的执行权限 chmod 777 /var/run/supervisord.sock chmod 777 /var/log 如果报错 error: , [Errno 2] No such file or directory: file: /usr/lib64/python2.7/socket.py line: 224 则可以尝试将进程杀死再重新启动 ps aux | grep supervisord # 根据pid杀死进程 kill pid # 重新启动superviosr supervisord -c /etc/supervisor/supervisord.conf supervisorctl -c /etc/supervisor/supervisord.conf supervisor.sock 文件报错 unix:///tmp/supervisor.sock no such file # 或则 unix:///var/run/supervisor.sock no such file 说明没在对应位置找到supevisor.sock文件 解决方法是直接到指定目录下创建文件，修改文件权限，并取消过时的套接字 $ touch /var/run/supervisor.sock $ chmod 777 /var/run/supervisor.sock $ sudo unlink /var/run/supervisor.sock 问题一 Unlinking stale socket /var/run/supervisor/supervisor.sock 参考： supervisor 从安装到使用 supervisor安装和自启动的一些问题 解决方法： $ sudo unlink /var/run/supervisor/supervisor.sock 问题二 Error: Another program is already listening on a port that one of our HTTP servers is configured to use. Shut this program down first before starting supervisord. For help, use /bin/supervisord -h 如字面意思，supervisor已经在运行了，但可能不是通过正确的方式启动，以至于 supervisor无法在shell中使用命令启动。 解决方法： 找出supervisor进程pid后kill后重新启动 $ ps -aux | grep supervisor root 3306 0.0 3.4 223840 17212 ? Ss 2月16 0:31 /usr/bin/python /bin/supervisord -c /etc/supervisor/supervisord.conf root 19818 0.0 3.2 223548 16200 ? Ss 12:13 0:00 /usr/bin/python /bin/supervisord -c /etc/supervisord.conf clip 19870 0.0 0.1 112724 992 pts/0 S+ 12:17 0:00 grep --color=auto supervisor 将找到的进程强行kill $ sudo kill 3306 $ sudo kill 19818 $ sudo supervisord -c /etc/supervisor/supervisord.conf 问题三 django: ERROR (no such process) 修改supervisord.conf文件，找到 file=/var/run/supervisor/supervisor.sock ; (the path to the socket file) chmod=0700 ; sockef file mode (default 0700) 将700改成777，再重启服务便可 可能会用到的操作 启动Virtualenv虚拟环境中的python程序 要启动Virtualenv中的python进程，需要对supervisor的配置文件做修改， 普通的配置文件是无法直接启动其程序的，需要在command命令上标注好启动 程序的环境。 其中directory文件目录指向Virtualenv的虚拟目录， /root/gpsenv/gpsenv # 第二个gpsenv为Virtualenv的环境目录 commnd运行命令处需要指向其运行目录的/bin/目录下，其后的运行命令直接 指向程序文件便可， /root/gpesenv/gpsenv/bin/ # 第二个gpsenv为Virtualenv的环境目录 Virtualenv有时会使用同一个程序文件管理多个虚拟环境中的python程序， 这时只需要在程序文件中指定号启动文件便可，比如使用绝对路径 python /root/gpsenv/gpsenv/manage.py runserver 0.0.0.0:8000 # 其后的 `runserver 0.0.0.0:8000`指定了其运行的地址和端口 具体配置参考如下： [program:django] directory=/root/gpsenv/gpsenv command=/root/gpsenv/gpsenv/bin/python /root/gpsenv/manage.py runserver 0.0.0.0:8000 autostart=true autorestart=true startretries=10 redirect_stderr=true stdout_logfile=/var/log/supervisor/django.log environment=ASPNETCORE_ENVIRONMENT=\"Development\" centos下开机启动supervisor 在/usr/lib/systemd/system/下新增/修改文件supervisord.service # supervisord service for systemd (CentOS 7.0+) # by ET-CS (https://github.com/ET-CS) [Unit] Description=Supervisor daemon [Service] Type=forking ExecStart=/usr/bin/supervisord -c /etc/supervisord.conf ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown ExecReload=/usr/bin/supervisorctl $OPTIONS reload KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target 其中ExecStart=/usr/bin/supervisord -c /etc/supervisord.conf为启动配置文件目录 设置开机启动 systemctl enable supervisord.service 配置环境变量 在进程配置文件中加入environment以配置环境变量，格式为 ;environment=KEY=\"value\" ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的 环境变量，在这里可以设置supervisord进程特有的其他环境变量。 supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的这些环境变量也会被子进程继承。 小例子：environment=name=\"haha\",age=\"hehe\" 默认为不设置。。。非必须设置 注意 如果正常写入配置重启之后还是读取不到环境变量，可能需要将supervisord.conf 配置文件做修改，找到 environment=DB_HOSTS_ENV=localhost,REDIS_HOSTS_ENV=localhost,ALLOWED_HOSTS_ENV=120.79.23.89 ; (key value pairs to add to environment) 请根据实际情况写入，具体逻辑可以理解为将环境变量写入supervisord的环 境，而进程的配置文件中环境变量的设置则声明了可以怎么获取，从supervisord 的进程中取得的环境变量 参考 使用supervisor管理进程 CentOS7——supervisor安装配置实战 supervisor 永不挂掉的进程 安装以及使用 centos安装supervisor 辅助队列任务 闲言碎语 一开始误以为我的环境是python3,所以要安装python3版本的supervisor 但是 sudo pip3 install supervisor 总是安装不上去，google查了一下发现supervisor4.0适配python3的版本还处于 测试中，暂无法使用。 这就很困扰了，又查了半天，打算弄个环境来运行supervisor时，大佬又指点了我 以下，这个supervisor只是个管理进程的软件，与你使用的语言无关 一语点醒梦中人，我现在是python3和python2并存的状态，python3装不上去可以使用python2来安装使用啊 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/windows/readme.html":{"url":"book/windows/readme.html","title":"Windows","keywords":"","body":"By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:58:12 "},"book/windows/windows-update-close.html":{"url":"book/windows/windows-update-close.html","title":"windows自动更新关闭","keywords":"","body":"windows自动更新关闭 如何完全禁止win10自动更新（自动升级） Win10更新并关机怎么取消没有关机按钮如何操作 打开运行面板输入services.msc,选中update进入禁用 关闭开机启动项 打开任务管理器，切换到“启动”视图，禁用选项就行 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/redis.html":{"url":"book/redis.html","title":"Redis","keywords":"","body":"Redis install redis Ubuntu sudo apt-get update sudo apt-get install redis-server 启动redis redis-server 查看redis是否有好好启动，输入 redis-cli 如果redis正常启动将会打开redis的shell，在终端显示 redis 127.0.0.1:6379> 127.0.0.1是本机IP，6379时redis的默认服务器端口，可以输入命令 redis 127.0.0.1:6379> ping PONG 显示PONG代表redis安装好了 修改Redis数据目录 参考：Redis 数据存储位置 导出数据 redis修改data目录之后，RDB和AOF写入失败 打开配置文件查看 $ vim /etc/redis/redis.conf 找到 # The working directory. # # The DB will be written inside this directory, with the filename specified # above using the 'dbfilename' configuration directive. # # The Append Only File will also be created inside this directory. # # Note that you must specify a directory here, not a file name. dir /var/lib/redis 出现的错误 启动redis报错 参考：Ubuntu下启动 Redis时， 提示 \"Can't open the log file: Permission denied failed\" $ service redis-server start Starting redis-server: *** FATAL CONFIG FILE ERROR *** Reading the configuration file, at line 171 >>> 'logfile /var/log/redis/redis-server.log' Can't open the log file: Permission denied failed 原因：redis-server.log执行权限不够 解决方法： $ sudo chmod 777 /var/log/redis/redis-server.log redis-cli 报错 $ redis-cli Could not connect to Redis at 127.0.0.1:6379: Connection refused 解决方法：修改配置文件 $ find / | grep redis.conf /etc/redis/redis.conf $ vim /etc/redis/redis.conf 找到 bind 127.0.0.1 ::1 这行，将其改为： bind 127.0.0.1 保存后退出，并重启服务 $ redis-server /etc/redis/redis.conf $ redis-cli By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/selserver2008-trigger.html":{"url":"book/selserver2008-trigger.html","title":"SQLServer2008触发器","keywords":"","body":"SQL Server 2008 R2 触发器调用python SQL Server 触发器 创建触发器 reconfigure go exec sp_configure 'show advanced options',1 reconfigure go exec sp_configure 'xp_cmdshell',1 go reconfigure go use test go if exists(select name from sysobjects where name='trig_python1' ) Drop trigger trig_python1 go create Trigger trig_python1 on test_table after insert,update,delete as begin declare @res char(2000) select @res=convert(char(100),id)+title+content from Inserted select @sql = 'C:/python3-32/python E:1.py ' +@res exec xp_cmdshell @sql select * from inserted end go # 语法 # 创建触发器 CREATE TRIGGER Trigger_Name --触发器名，在一个数据库中触发器名是唯一的。 ON Table_Name | View_Name --触发器所在的表或者视图。 AFTER(FOR)|Instead Of INSERT,DELETE,UPDATE --定义成AFTER或Instead Of类型的触发器。 --AFTER跟FOR相同，不可在视图上定义AFTER触发器 -- 后面是触发器被触发的条件，最少有一个，可以邮多个。如果有多个用逗号分开，顺序无要求。 www.2cto.com AS --触发器要执行的操作 BEGIN --BEGIN跟END组成一个代码块，可以写也可以不写，如果触发器中执行的SQL语句比较复杂，用BEGIN和END会让代码更加整齐，更容易理解。 END GO --GO就代表结操作完毕 # 启用xp_cmdshell reconfigurego exec sp_configure 'show advanced options',1 reconfigure go exec sp_configure 'xp_cmdshell',1 go reconfigure go ``` # 拼接多列数据 select @res=convert(char(100),id)+title+content from Inserted # 将查询结果传值给python程序 select @sql = 'C:/python3-32/python E:1.py ' +@res exec xp_cmdshell @sql 注意 触发器将会生成临时表，要得到当前插入的数据应该查询临时表 1，After触发器只能用于数据表不能用于视图；Instead Of触发器两者皆可，设置为With Check Option的视图也不允许建立Instead Of触发器。两种触发器都不可以建立在临时表上。 2，一个数据表可以有多个触发器，但是一个触发器只能对应一个表。 3，在同一个数据表中，对每个操作（如Insert、Update、Delete）而言可以建立许多个After触发器，而Instead Of触发器针对每个操作只有建立一个。 4，如果针对某个操作即设置了After触发器又设置了Instead Of触发器，那么Instead of触发器一定会激活，而After触发器就不一定会激活。 5，不同的SQL语句，可以触发同一个触发器，如Insert和Update语句都可以激活同一个触发器。 6，触发器名在所在的数据库里必须是唯一的。由于触发器是建立中数据表或视图中的，所以有很多人都以为只要是在不同的数据表中，触发器的名称就可以相同，其实触发器的全名（Server.Database.Owner.TriggerName）是必须 唯一的，这与触发器在哪个数据表或视图无关。 7，关键字AFTER可以用For来代取，它们的意思都是一样的，代表只有在数据表的操作都已正确完成后才会激活的触发器。 参考 SQL Server 触发器学习总结 sql server 2008如何打开和禁用xp_cmdshell 初学sql server 2008之触发器 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/mysql.html":{"url":"book/mysql.html","title":"Mysql","keywords":"","body":"Ubuntu系统下安装使用MySQL sudo apt-get update sudo apt-get install mysql-server 之后可以运行安全脚本 mysql_secure_installation 大体提示为： 保護MySQL服務器部署。 使用空白密碼連接到MySQL。 VALIDATE PASSWORD PLUGIN可用於測試密碼 並提高安全性。它檢查密碼的強度 並允許用戶只設置那些密碼 足夠安全。你想設置VALIDATE PASSWORD插件嗎？ 按y | Y表示是，否則為No的任何其他鍵： LOW長度> = 8 MEDIUM長度> = 8，數字，大小寫混合和特殊字符 STRONG長度> = 8，數字，大小寫混寫，特殊字符和字典文件 請輸入0 = LOW，1 = MEDIUM，2 = STRONG：@ Jun819628 密碼的估計強度：100 您是否希望繼續提供密碼？（按y | Y表示是，其他任何鍵表示否）： 默認情況下，MySQL安裝有一個匿名用戶， 允許任何人登錄MySQL而不必擁有 為他們創建的用戶帳戶。這僅適用於 測試，並使安裝更順暢。 您應該在進入生產之前將其刪除 環境。 刪除匿名用戶？ （按y | Y表示是，任何其他鍵表示否）： 通常，只允許root連接 'localhost'的。這可以確保有人無法猜測 來自網絡的root密碼。 禁止遠程登錄？ （按y | Y表示是，任何其他鍵表示否）： ......跳過 默認情況下，MySQL附帶一個名為'test'的數據庫 任何人都可以訪問這也僅用於測試， 並且應該在進入生產之前將其移除 環境。 刪除測試數據庫並訪問它？ （按y | Y表示是，任何其他鍵表示否）： 刪除測試數據庫...... 成功。 刪除測試數據庫的權限... 成功。 重新加載權限表將確保所有更改 到目前為止，將立即生效。 現在重新加載權限表？ （按y | Y表示是，任何其他鍵表示否）： 根据具体意愿设置就行了 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/postgresql.html":{"url":"book/postgresql.html","title":"Postgresql","keywords":"","body":"PostgreSQL install and use 参考： postgresql 数据导入导出 ubuntu 下 PostgreSQL 使用小记 PostgreSQL新手入门 修改postgres密码 PostgreSQL 9.3.1 中文手册 安装PostgreSQL(debian) 安装PostgreSQL的服务端和客户端： $ sudo apt-get install postgresql postgresql-client 初次安装后会默认生成一个名为\"postgres\"的Linux用户、名为\"postgres\"的 数据库和名为\"postgres\"的数据库用户。 在使用Postgresql时，psql将会默认使用和当前Linux用户名同名的数据库用户 名登录数据库 服务 # 查看状态 sudo /etc/init.d/postgresql status # 启动 sudo /etc/init.d/postgresql start # 停止 sudo /etc/init.d/postgresql stop # 重启 sudo /etc/init.d/postgresql restart 错误 启动错误 安装后启动出现： psql: could not connect to server: No such file or directory Is the server running locally and accepting connections on Unix domain socket \"/var/run/postgresql/.s.PGSQL.5432\"? 参考：Why psql can't connect to server? 找到pg_hba.conf配置文件，选摘： # Database administrative login by Unix domain socket local all postgres peer # TYPE DATABASE USER ADDRESS METHOD # \"local\" is for Unix domain socket connections only local all all peer # IPv4 local connections: host all all 127.0.0.1/32 md5 # IPv6 local connections: host all all ::1/128 md5 其中： # \"local\" is for Unix domain socket connections only local all all peer 将peer改为trust，并重启服务 sudo /etc/init.d/postgresql restart 启动服务错误 * Restarting PostgreSQL 10 database server * Error: Config owner (postgres:101) and data owner (root:0) do not match, and config owner is not root [fail] 某种原因导致一些目录和文件的所有者“不正确”，解决方法： 修改目录/文件所有者，一般只要改/var/lib/postgresql/文件夹下的便可 $ chown -R postgresql:postgresql /var/lib/postgresql/ 在docker中部署postgresql启动错误 1、 web_1 | django.db.utils.OperationalError: FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"postgres\", SSL on web_1 | FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"postgres\", SSL off web_1 | db-com | 2019-02-26 12:11:43.925 CST [19] postgres@postgres FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"p ostgres\", SSL on db-com | 2019-02-26 12:11:43.928 CST [20] postgres@postgres FATAL: no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"p ostgres\", SSL off 如上提示，由于数据库身份验证失败导致 由于首次安装postgresql时会产生一个postgres的Unix用户和一个postgres 的数据库用户，Unix用户的密码可以不管，但由于没有设置密码，要执行postgres 命令必须切换到postgres用户下。而数据库用户postgres没有设置密码就会 导致外部进程无法连接，因为该数据库用户没有密码，连接时不给密码就会提示 2019-02-26 14:16:11.230 CST [19] postgres@postgres FATAL: password authentication failed for user \"postgres\" 2019-02-26 14:16:11.230 CST [19] postgres@postgres DETAIL: User \"postgres\" has no password assigned. Connection matched pg_hba.conf line 95: \"host all all 0.0.0.0/0 md5\" 2019-02-26 14:16:11.233 CST [20] postgres@postgres FATAL: password authentication failed for user \"postgres\" 2019-02-26 14:16:11.233 CST [20] postgres@postgres DETAIL: User \"postgres\" has no password assigned. Connection matched pg_hba.conf line 95: \"host all all 0.0.0.0/0 md5\" 而随便给个密码又会 FATAL: password authentication failed for user \"postgres\" 解决方法就是修改数据库用户postgres的密码，切换到Unix的postgres用户下执行 $ su postgres $ psql --command \" ALTER USER postgres WITH PASSWORD '123456';\" 在Dockerfile中则是 USER postgres RUN /etc/init.d/postgresql restart \\ && psql --command \" ALTER USER postgres WITH PASSWORD '123456';\" \\ && /etc/init.d/postgresql stop 2、 db-com | 2019-02-26 13:41:56.227 CST [11] LOG: could not open temporary statistics file \"/var/run/postgresql/10-main.pg_stat_tmp/global.tmp\": No such file or directory 按错误日志，创建该目录，并将所有者改为postgres $ mkdir -p /var/run/postgresql/10-main.pg_stat_tmp \\ $ chown -R postgres:postgres /var/run/postgresql/10-main.pg_stat_tmp 3、 db-com | 2019-02-26 13:50:14.828 CST [1] LOG: listening on IPv4 address \"127.0.0.1\", port 5432 db-com | 2019-02-26 13:50:14.828 CST [1] LOG: could not bind IPv6 address \"::1\": Cannot assign requested address db-com | 2019-02-26 13:50:14.828 CST [1] HINT: Is another postmaster already running on port 5432? If not, wait a few seconds and retry. db-com | 2019-02-26 13:50:14.831 CST [1] LOG: listening on Unix socket \"/var/run/postgresql/.s.PGSQL.5432\" db-com | 2019-02-26 13:50:14.863 CST [6] LOG: database system was shut down at 2019-02-26 12:28:48 CST db-com | 2019-02-26 13:50:14.881 CST [1] LOG: database system is ready to accept connections 但是web服务连接时却出现 web_1 | django.db.utils.OperationalError: could not connect to server: Connection refused web_1 | Is the server running on host \"db\" (172.18.0.3) and accepting web_1 | TCP/IP connections on port 5432? 这个问题比较微妙，我目前已知的原因有三个，目前正在接触的web项目为django， 所以此处列出django的示例，提供参考 1、postgresql的postgresql.conf 在该文件中找到 # - Connection Settings - listen_addresses = '127.0.0.1' # what IP address(es) to listen on; # comma-separated list of addresses; # defaults to 'localhost'; use '*' for all # (change requires restart) port = 5432 # (change requires restart) max_connections = 100 # (change requires restart) # superuser_reserved_connections = 3 # (change requires restart) 将listen_addresses改为listen_addresses = '0.0.0.0' 这是由于，在容器中启动时127.0.0.1总是指向容器本身，导致无法监听来自外部其他 容器的访问。 2、postgresql的pg_hba.conf 在该文件中中找到 # Database administrative login by Unix domain socket local all postgres peer # TYPE DATABASE USER ADDRESS METHOD # \"local\" is for Unix domain socket connections only local all all trust # IPv4 local connections: host all all 127.0.0.1/32 md5 # IPv6 local connections: host all all ::1/128 md5 保证和上面代码内容相同，其中trust在较新的版本中可以使用peer代替 3、django的配置文件settings.py 找到连接数据库的配置内容 DATABASES = { 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'postgres', 'USER':'postgres', 'PASSWORD':'123456', 'HOST':'db', 'PORT':'5432', } 其中'HOST':'db'需要指向具体容器的服务名称，原因和上面一样，如果使用 localhost将会一直指向容器本身导致无法正确访问数据库。也就是django会在 当前容器下查找数据库服务，但是数据库服务却在其他容器提供。 由于我时使用docker-compose来管理容器，而compose则是项目和服务 的概念，这里稍微转换一下 compose将数个容器提供的服务整个成一起，称为一个项目，而每个容器本身提供服务， 故将容器称为服务 如果没有使用compose的话，比如直接使用docker网桥服务来连接容器将的 通信，则这里的HOSTS则指向该容器在网桥中的IP，可以使用 docker inspect 来查看具体容器的IP 4、 PermissionError: [Errno 13] Permission denied: '/code/jimi_commd.log' 用更高的用户权限或者修改相关文件的权限和所有者 5、 no pg_hba.conf entry for host \"172.18.0.4\", user \"postgres\", database \"postgres\", SSL on 将172.18.0.4添加进pg_hba.conf echo \"host all all 172.18.0.4/16 md5\" >> pg_hba.conf By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/shell.html":{"url":"book/shell.html","title":"shell","keywords":"","body":"SHELL 参考 egrep 命令 Shell特殊变量：Shell $0, $# , $*, $@, $?, $$和命令行参数 Shell 运算符：Shell 算数运算符、关系运算符、布尔运算符、字符串运算符等 Shell脚本编程30分钟入门 Shell 基本运算符 运算符参考 特殊变量 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(\" \")包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。一般情况下，大部分命令执行成功会返回 0，失败返回 1。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 $* 和 $@ 的区别 $* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(\" \")包含时，都以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 但是当它们被双引号(\" \")包含时，\"$*\" 会将所有的参数作为一个整体，以\"$1 $2 … $n\"的形式输出所有参数；\"$@\" 会将各个参数分开，以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 运算符 算术运算符 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 加法 expr $a + $b 结果为 30。 减法 expr $a - $b 结果为 -10。 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符 下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 逻辑运算符 以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 && 逻辑的 AND [[ $a -lt 100 && $b -gt 100 ]] 返回 false || 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true 字符串运算符 下表列出了常用的字符串运算符，假定变量 a 为 \"abc\"，变量 b 为 \"efg\"： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n \"$a\" ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 egrep 用途 搜索文件获得模式。 语法 egrep [ -h ] [ -i ] [ -p[ Separator ] ] [ -s ] [ -u ] [ -v ] [ -w ] [ -x ] [ -y ] [ [ -b ] [ -n ] | [ -c | -l | -q ] ] { { -ePattern | -fStringFile } ... |Pattern } [ File ... ] 描述 egrep 命令会在输入文件（缺省值为标准输入）中搜索与用 Pattern 参数指定的模式相匹配的行。这些模式是完整的正则表达式就像在 ed 命令中的那样（除了 \\（反斜杠）和 \\（双反斜杠））。以下规则也应用于 egrep 命令: 一个正则表达式后面带一个 ＋ （加号）会匹配一个或多个的正则表达式。 一个正则表达式后面带一个 ？ （问号）会匹配零个或一个该正则表达式。 由 | （竖线）或者换行符隔开的多个正则表达式会匹配与任何一个正则表达式所匹配的字符串。 一个正则表达式可以被包括在“()”（括号）中进行分组。 换行符将不会被正则表达式匹配。 运算符的优先顺序是 [, ], *, ?, +, 合并, | 和换行符。 注：egrep 命令与 grep 命令带 -E 标志是一样的，除了错误消息和使用情况消息不同以及 -s 标志的功能不同之外。 egrep 命令会显示包含该匹配行的文件，如果您指定了多于一个 File 参数的话。对 shell 有特殊含义的字符 （$, *, [, |, ^, (, ), \\ ) 出现在 Pattern 参数中时必须带双引号。如果 Pattern 参数不是简单字符串，通常必须用单引号将整个模式括起来。在诸如 [a-z]之类的表达式中，减号意味着按照当前整理顺序“直到”。整理顺序可以定义等价的类以供在字符范围中使用。它使用了快速确定性的算法，有时需要外部空间。 shell expect自动交互 参考：Shell脚本交互之：自动输入密码 Ubuntu使用Spawn和expect实现ssh自动登陆 Expect中的timeout设定 linux expect自动登录ssh 需要安装except才能使用 $ apt-get install tcl tk expect 要运行expect脚本必须使用 $ expect filename.sh 语法 这是一个设置自动修改postgresql密码的脚本 # !/bin/expect spawn psql expect \"postgres=# \" send \"\\\\password postgres\\r\" expect \"Enter new password:\" send \"123456\\r\" expect \"Enter it again:\" send \"123456\\r\" expect \"postgres=# \" send \"\\\\q\\r\" expect eof !/bin/expect 指明这是个expect脚本 spawn 后面接续指令，开始自动交互， expect 期待控制台输出的结果，符合这个结果就执行下面的send send当expect获得预期结果时将会执行本语句，记得加上\\r来模拟回车 interact 交互模式,用户会停留在远程服务器上面. set timeout -1 没有超时时间 set timeout 30设置超时时间为30秒 使用echo指令向文件写入内容 Linux学习笔记——如何使用echo指令向文件写入内容 覆盖文件内容 echo \"text\" > text.txt 使用>将会覆盖文件夹原内容写入，如果文件不存在则创建文件 追加文件内容 echo \"text\" >> text.txt 使用>>向文件追加内容，不会改动原内容 By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 11:42:31 "},"book/other/readme.html":{"url":"book/other/readme.html","title":"Other","keywords":"","body":"By Clip all right reserved，powered by Gitbook修订时间： 2019-10-10 09:58:12 "},"book/git/git.html":{"url":"book/git/git.html","title":"GIT","keywords":"","body":"git分布式版本控制系统 参考 Git教程 git - 简易指南 七步搭建 Git 服务器 git从远程库同步到本地仓库 Git 基础 - 远程仓库的使用 起步 - 安装 Git Download for Linux and Unix CentOS 7 安装最新的 Git Git的诞生 不得不提一下Git的诞生，看了几次都觉得牛逼得不行。（摘录自廖雪峰的Git教程） 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 安装Git Linux上安装Git 在终端输入git，看看系统有没有安装好 $ git usage: git [--version] [--help] [-C ] [-c =] [--exec-path[=]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=] [--work-tree=] [--namespace=] [] 大多数linux都会友好的告诉你是否安装了 如果没有安装的话就安装一下 先安装依赖： ubuntu/debian: $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev centos: $ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel 进行安装： ubuntu/debian: $ sudo apt-get install git centos $ yum install git 源码包安装 下载最新版git安装包 $ wget https://github.com/git/git/archive/v2.9.2.tar.gz 解压到指定目录 $ tar -xzvf v2.9.2.tar.gz -C ~/app/ 安装 $ cd git-2.9.2 $ make prefix=/usr/local/git all $ make prefix=/usr/local/git install 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 创建版本库只需要你选择一个“适合”的目录，执行git init便可，不管是什么目录， 这里我选择新建一个目录给git使用 # 创建目录 $ mkdir /home/user/git # 移动到目录下 $ cd /home/user/git # 使其变成git仓库 $ git init 仓库就建好了，可以使用命令ls -al在仓库目录下找到一个隐藏的目录.git 工作流 你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有 实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动； 最后是HEAD，指向你最近一次提交后的结果 常用命令 查看仓库当前状态 git status 将改动添加到缓存区 git add git add * 实际提交改动 git commit -m '代码提交信息' 查看文件改动前后不同之处 git diff 查看代码提交日志（由近到远） git log # 简化日志输出 git log --pretty=oneline 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 版本回退 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 git reset --hard HEAD^ 如果回退到之前的版本，却发现不是自己想要的版本，想撤销这次操作， 但是这个时候再使用git log你就看不到最新的哪个版本了。毕竟上面已经明确 告诉你了git log显示的是由近到远的提交日志。这时候就需要用到commit id了。 运气好的话，在哪里打印过日志，就翻上去，找到最新版本的commit id，使用 commit id来回到未来的某个版本,比如这里看到先前最新的版本commit id 为1094a，那么就可以这么操作 git reset --hard 1094a 如果没有记录这个commit id却又后悔了回退版本，想撤销这次操作回到先前 未来的某个版本上，这个时候可以使用 git reflog git提供git reflog来记录你的每一次操作，便可顺藤摸瓜找到先前的commit id 来回到指定的版本 撤销修改 当想要丢弃本次修改的时候怎么办，git是记录修改的，不是什么记事本，你撤销 回去便会回到原状，在工作区的每一个修改都将被git所记录。 什么是修改呢，创建一个文件夹，新建一个文件，在代码里增加一行，一个符号，都是修改 操作了修改之后，使用git status，git将会明确告诉你那些文件被修改了，并且 会提示你接下来要怎么操作 如果你还没有将文件提交到缓存区的话 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 根据提示，你可以使用git checkout -- 丢弃此次修改 而如果已经将文件添加到缓存区时 $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: readme.txt 同样提示你可以使用git reset HEAD 来撤销此次添加到缓存区的文件 如果你已经git commit -m '提交说明'将修改提交了上去，就直接使用版本回退， 毕竟代码是在自己电脑上修改，都还有救，而但你将代码提交到git服务器上时， 那么，没救了，等死吧 删除 在git工作区中删除文件也属于修改。 如果确实需要删除文件，需要使用git rm ，并提交上去 $ rm test.txt $ git rm test.txt $git commit -m '说明' 分支管理 创建分支 git checkout -b dev # 这个命令相当于,下面两条 git branch dev git checkout dev dev是分支名，是自定义的名字 查看当前分支 git branch 切换当前分支 git checkout 合并某个分支到当前分支git merge 删除分支git branch -d 强行删除分支git btanch -D 查看分支合并图 git log --graph 禁用快速合并(Fast Forward)，并生成一个新的提交 git merge --no-ff -m \"text\" 创建本地分支与远程分支的联系 git branch --set-upstream-to origin/ 保存工作现场 廖雪峰的Git教程 `git stash` 将当前工作现场“储藏起来” 用git stash list查看保存的工作现场 恢复的方式有两种: git stash apply ‘stash’内容不删除，删除使用git stash drop git stash pop，恢复的同时把stash内容也删了 多次stash，恢复用git stash list查看，然后恢复指定的stash git stash apply stash@{0} 搭建git服务器 git是分布式版本控制系统，同一个git仓库可以分布到不同的机器上。 多个机器上互相推送克隆，但为了能够避免其他人的电脑没开机等情况，这个时候 需要一台24小时开机的设备充当git服务器，以便每个人都将自己的代码修改推送 到这台机器上。 同样安装git $ sudo apt-get install git 和客户端不同的地方在于，这个是要充当服务器的角色，所以需要一个账户以供给 其他人登录推送代码。所以需要创建一个账号 $ sudo adduser git 和客户端一样初始化一个目录作为git仓库 $ mkdir /gitpro $ cd /gitpro $ git init --bare name.git 加上--bare创建一个名为name的裸仓库。裸仓库没有工作区，因为服务器上 的git仓库纯粹是为了共享，同时也避免了用户直接登录到服务器上修改工作区。 通常服务器上的的git仓库会以.git后缀。 因为我们现在不是使用上面创建的git用户来操作这些，所以这个仓库的所有者 是当前用户（我用root用户操作，所以该文件的所有者是root），需要将所有者 改为git用户，这样才能使用git用户操作该目录 $ sudo chown -R git:git name.git 为了更安全的登录git服务器推送代码，需要用到ssh免密登录，这里只需要手机客户端 的公钥，保存在git用户目录下的.ssh/authorized_keys内便可，具体可以参考本 博客的另一篇文章“SSH秘钥(免密登录)” 需要注意的是，.ssh文件夹和authorized_keys的文件所有者必须是git用户。 并且，.ssh文件夹权限为700，authorized_keys文件权限为600。 最后禁用git用户使用shell登录，直接变价/etc/passwd文件，找到 git:x:1001:1001:jyt,,jyt,:/home/git:/bin/bash 将其改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 克隆远程仓库 git clone git@server:/gitpro/name.git 上文提到的server gitpro name.git记得替换成自己的 关联远程仓库 git服务器有了之后，需要在客户端上关联远程仓库，以便从机器推送到服务器上 添加远程仓库 git remote add origin git@server:/gitpro/nam.git 查看关联的远程仓库名 git remote 删除关联的远程仓库名 git remote remove 查看仓库信息 git remote show 远程仓库重命名 git remote rename 推送数据到远程库 git push -u origin master 这里的origin指的是关联的远程仓库名。master指的是要推送的分支。 抓取远程仓库并同步到本地仓库 # 抓取远程仓库 git fetch origin master # 比较远程仓库和本地仓库差异 git log master.. origin/master # 合并远程库 git merge origin/master By Clip all right reserved，powered by Gitbook修订时间： 2019-10-11 11:46:41 "}}